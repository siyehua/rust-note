# Rust å­¦ä¹ ç¬”è®°

## ç¼–è¯‘é…ç½®

### rust å‘½ä»¤

```shell
# æŸ¥çœ‹å½“å‰çš„ rust ç‰ˆæœ¬
rustc --version
# å‡çº§ rust 
rustc update
# ç¼–è¯‘ä¸€ä¸ª rust æ–‡ä»¶
rustc main.rs
# æŸ¥çœ‹ æ–‡æ¡£
rustup doc
```

### cargo å‘½ä»¤

```shell
# åˆ›å»ºä¸€ä¸ªé¡¹ç›®, hello-rust æ˜¯é¡¹ç›®åç§°ï¼Œé¡¹ç›®åç§°éµå¾ª xxx-xxx åŸåˆ™ï¼Œå­—æ¯éƒ½ç”¨å°å†™å­—æ¯ 
carg new hello-rust --vcs=git
# ç¼–è¯‘ä¸€ä¸ªé¡¹ç›®, ç¼–è¯‘ä¹‹åä¼šç”Ÿæˆä¸€ä¸ª debug çš„ç›®å½•ï¼Œè¿›å…¥è¯¥ç›®å½•ä¹‹åå°±å¯ä»¥è¿è¡Œ
# å¦‚æœéœ€è¦ç¼–è¯‘ release çš„ï¼Œå¯ä»¥ä½¿ç”¨ -help æŸ¥çœ‹å¸®åŠ©ï¼Œé»˜è®¤ç¼–è¯‘çš„æ˜¯ debug
cargo build
# è¿è¡Œä¸€ä¸ªé¡¹ç›®
cargo run 
# è¿è¡Œæ—¶æ£€æŸ¥ä¸€ä¸ªé¡¹ç›®æƒ…å†µ
# check å‘½ä»¤è¦æ¯” run å¿«ï¼Œå› ä¸ºå®ƒä¸éœ€è¦è¿è¡Œï¼Œå¦‚æœé¡¹ç›®éå¸¸å¤§ï¼Œéœ€è¦ç¼–è¯‘å¾ˆä¹…æ‰èƒ½è¿è¡Œï¼Œè€Œç¨å¾®æœ‰ç‚¹é”™è¯¯
# å°±ä¼šå¯¼è‡´è¿è¡Œå¤±è´¥ï¼Œä½¿ç”¨ run å‘½ä»¤å°±ä¼šè®©äººæŠ“ç‹‚ï¼Œcheck å‘½ä»¤å°±èƒ½æ”¹å–„è¿™ç§æƒ…å†µ
cargo check 
```

## é¡¹ç›®ç»“æ„

ä¸‹é¢å±•ç¤ºäº†ä¸€ä¸ªç®€å•çš„é¡¹ç›®ç»“æ„ï¼š<br>

```
.
â”œâ”€â”€ Cargo.lock // å½“å‰é¡¹ç›®ä¸ç¬¬ä¸‰æ–¹çš„ç‰ˆæœ¬é…ç½®ï¼Œé€šå¸¸è¿™ä¸ªä¹Ÿä¼šåŠ å…¥åˆ° git ç‰ˆæœ¬æ§åˆ¶ä¸­ï¼Œå› ä¸ºæœ‰çš„é¡¹ç›®å¯èƒ½éœ€è¦ç‰¹å®šçš„ç‰ˆæœ¬æ‰èƒ½ç¼–è¯‘
â”œâ”€â”€ Cargo.toml // å½“å‰é¡¹ç›®ä¸ç¬¬ä¸‰æ–¹çš„ç‰ˆæœ¬é…ç½®, ä¸ lock ä¸åŒï¼Œè¿™é‡Œæ˜¯é…ç½®çš„åœ°æ–¹
â”œâ”€â”€ readme.md // é¡¹ç›®è¯´æ˜
â”œâ”€â”€ src // é¡¹ç›®æºç å­˜æ”¾ä½ç½®
â”‚Â Â  â””â”€â”€ main.rs // é¡¹ç›®æºä»£ç 
â””â”€â”€ target // ç¼–è¯‘åçš„ç›®å½•å­˜æ”¾ä½ç½®ï¼Œé€šå¸¸è¯¥æ–‡ä»¶ä¸ä¼šåŠ å…¥åˆ° git ç‰ˆæœ¬æ§åˆ¶ä¸­
    â”œâ”€â”€ CACHEDIR.TAG 
    â””â”€â”€ debug // ä¸Šé¢æåˆ°çš„ cargo build åçš„äº§ç‰©å°±å­˜åœ¨å½“å‰ç›®å½•ä¸‹
        â”œâ”€â”€ build
        â”œâ”€â”€ deps
        â”œâ”€â”€ examples
        â””â”€â”€ incremental
```

### Cargo.toml é…ç½®æ–‡ä»¶è¯¦è§£

```toml
[package]
name = "hello_cargo" # å½“å‰é¡¹ç›®åç§°
version = "0.1.0" # å½“å‰é¡¹ç›®ç‰ˆæœ¬
edition = "2021" # ä¿®æ”¹æ—¶é—´

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
rand = "0.8.5" # è¡¨ç¤ºç”¨äº†ä¸€ä¸ª rand ç¬¬ä¸‰æ–¹åº“ï¼Œç‰ˆæœ¬æ˜¯ 0.8.5
# æ·»åŠ å®Œä¹‹åï¼Œä½¿ç”¨ cargo build å°±å¯ä»¥æŠŠè¯¥ç¬¬ä¸‰æ–¹çš„ä»¥åŠå®ƒå…³è”çš„ç¬¬ä¸‰æ–¹éƒ½æ‹‰ä¸‹æ¥ï¼Œå¹¶å­˜å‚¨åˆ° .lock æ–‡ä»¶ä¸­

# ä½¿ç”¨éå›ºå®šç‰ˆæœ¬
#rand = "^0.8.5" # è¡¨ç¤ºç”¨æœ€æ–°çš„0.8.x ç‰ˆæœ¬ï¼Œè¯¥ç‰ˆæœ¬å§‹ç»ˆå°äº 0.9.0 
#å‰é¢è¯´äº† .lock æ–‡ä»¶ä¼šå°†ç¬¬ä¸‰æ–¹ç‰ˆæœ¬ç‰ˆæœ¬é”å®šåœ¨æŸä¸ªç‰ˆæœ¬ï¼Œä¾‹å¦‚ 0.8.6ï¼Œ è¿‡äº†ä¸€æ®µæ—¶é—´åï¼Œè¯¥ç¬¬ä¸‰æ–¹åº“çš„ä½œè€…
#å‘å¸ƒäº† 0.8.7ï¼Œ é¡¹ç›®ä¸ä¼šè‡ªåŠ¨æ›´æ–°åˆ°è¯¥ç‰ˆæœ¬ï¼Œå°½ç®¡ä½¿ç”¨äº† ^, è¦æƒ³ä¸»åŠ¨æ›´æ–°ï¼Œå¯æ˜¯ä½¿ç”¨ï¼šcargo update æ¥æ›´æ–°
#æ³¨æ„ï¼Œå¦‚æœæœ‰æ›´æ–°ï¼Œä¼šåŒæ­¥æƒ³æ”¹ .lock æ–‡ä»¶é”å®šçš„ç‰ˆæœ¬
```

### Cargo.lock ç‰ˆæœ¬è¯¦è§£

è¯¥æ–‡ä»¶ä¸éœ€è¦æ‰‹åŠ¨ç¼–è¾‘ï¼Œä¼šè‡ªåŠ¨æ ¹æ®ç¯å¢ƒç”Ÿæˆï¼Œ

```toml
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 3

[[package]]
name = "hello_cargo" # é¡¹ç›®åç§°
version = "0.1.0" # é¡¹ç›®ç‰ˆæœ¬
dependencies = [ # å½“å‰é¡¹ç›®ä¾èµ–çš„ç¬¬ä¸‰æ–¹
 "rand",
]

[[package]]
name = "rand" # ä¾èµ–çš„ç¬¬ä¸‰æ–¹
version = "0.8.5" # ç‰ˆæœ¬
source = "registry+https://github.com/rust-lang/crates.io-index" # æºç åœ°å€
checksum = "34af8d1a0e25924bc5b7c43c079c942339d8f0a8b57c39049bef581b46327404"
dependencies = [ # è¯¥ç¬¬ä¸‰æ–¹åˆä¾èµ–äº†å…¶ä»–çš„ç¬¬ä¸‰æ–¹
    "libc",
    "rand_chacha",
    "rand_core",
]
#... è¿˜æœ‰å¾ˆå¤š ...
```

## ç¼–ç å‰æ

è¿™é‡Œè¯´ä¸€ä¸‹ç¼–ç çš„åŸºç¡€æƒ…å†µ

```rust
// ä½¿ç”¨  use å¯¼å…¥æŸä¸ªåŒ…ï¼Œ :: ä¸¤ä¸ªå†’å·æ¥è¡¨ç¤ºå¼•ç”¨æŸä¸ªç±»
use std::io;
fn main(){ // fn è¡¨ç¤ºå‡½æ•°ï¼Œ main() è¡¨ç¤ºé¡¹ç›®çš„å…¥å£
    let guess = "123";
    println!("You guessed: {guess}"); // println! è¾“å‡º, {} æ¥å¼•å…¥å˜é‡
    println!("You guessed: {}", guess); // ä¹Ÿå¯ä»¥è¿™ä¹ˆå†™

    io::stdin() // è¾“å…¥
        .read_line(&mut guess)
        .expect("Failed to read line"); // é”™è¯¯æ•æ‰

    let guess: u32 = match guess.trim().parse() { // é”™è¯¯æ•æ‰ è¿”å›ä¸€ä¸ª Ok ä¸ Err, Ok é‡Œé¢æœ‰æ­£ç¡®çš„å€¼
        Ok(num) => num, 
        Err(_) => println!("error"),
    };
}
```

## å˜é‡ä¸ç±»å‹

rust ç±»å‹ç¼–è¯‘çš„æ—¶å€™å°±å·²ç»ç¡®å®š

```rust
let x = 5; // ç¼–è¯‘å®šä¹‰äº†ä¸€ä¸ªå˜é‡ x çš„ç±»å‹æ˜¯ i32ï¼Œ ä¸»è¦è¯¥å˜é‡ x æ˜¯ä¸å¯ä»¥ä¿®æ”¹çš„

x = 10; // è¿™ä¸€è¡Œä»£ç ä¼šæŠ¥é”™ï¼Œåº”è¯¥é»˜è®¤çš„ x æ˜¯ä¸å¯ä»¥ä¿®æ”¹çš„

let mut y = 10; // ä½¿ç”¨ mut æ¥è¡¨ç¤º y æ˜¯å¯å˜çš„
y = 20; // å¯ä»¥æ­£ç¡®çš„ç¼–è¯‘

let mut y = "I am string!"; // ç±»å‹è¦†ç›–ï¼Œå¯ä»¥å°† y çš„ç±»å‹ä¿®æ”¹æ”¹æˆ String, è¿™æ˜¯è¿å…è®¸çš„
y = 20; // æŠ¥é”™ï¼ ä¿®æ”¹ä¹‹å y å°±æ˜¯ String ç±»å‹ï¼Œæ­¤æ—¶å†èµ‹å€¼æˆ i32 ç±»å‹å°±ä¼šæŠ¥é”™
y = "new String"; // æ­£ç¡®

// å¸¸é‡ï¼Œ æ³¨æ„å¸¸é‡ä¸å¯ä»¥è¢«è¦†ç›–
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
// let mut THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3; // æŠ¥é”™
// println!("new {THREE_HOURS_IN_SECONDS}");
//   |
// 8 |     const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
//   |     ------------------------------------------------ the constant `THREE_HOURS_IN_SECONDS` is defined here
// 9 |     let mut THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
//   |             ^^^^^^^^^^^^^^^^^^^^^^ cannot be named the same as a constant
```

### æ•´å‹

i è¡¨ç¤ºæœ‰ç¬¦å·ï¼ŒèŒƒå›´æ˜¯ï¼š-(2n - 1) to 2n - 1 - 1  u è¡¨ç¤ºæ— ç¬¦å·ï¼Œ èŒƒå›´æ˜¯ï¼š0 to 2n - 1 - 1

|Length	|Signed	|Unsigned|
| --- | --- | --- |
|8-bit	|i8	|u8|
|16-bit	|i16	|u16|
|32-bit	|i32	|u32|
|64-bit	|i64	|u64|
|128-bit	|i128	|u128|
|arch	|isize	|usize|

### æµ®ç‚¹å‹

æµ®ç‚¹å‹æ¯”è¾ƒç®€å•ï¼Œåªæœ‰ä¸¤ç§ç±»å‹ï¼Œåˆ†åˆ«æ˜¯ f32 å’Œ f64, é»˜è®¤ç±»å‹æ˜¯ f64, å› ä¸ºå¸‚é¢ä¸Šå¤§å¤šæ•°çš„æœºå™¨64 ä½èƒ½æœ‰ 32 ä½çš„è¿è¡Œæ€§èƒ½

### è®¡ç®—

è®¡ç®—æ”¯æŒåŸºæœ¬çš„åŠ å‡ä¹˜é™¤ä¸å–ä½™æ“ä½œï¼Œä½†æ˜¯ä¸æ”¯æŒä¸¤ä¸ªä¸åŒç±»å‹çš„ç›´æ¥è®¡ç®—ï¼Œä¾‹å¦‚ï¼š

```rust
let a = 10;
let b = 20.0;
let c = a * b; // æŠ¥é”™
//   |
//   |     let c = a * b;
//   |               ^ no implementation for `{integer} * {float}`
//   |
//   = help: the trait `Mul<{float}>` is not implemented for `{integer}`
```

### å¸ƒå°”ç±»å‹

```rust
let a = true;
let b: bool = false;
```

### char ç±»å‹

åªå…è®¸è®¾ç½®å•ä¸ªå­—ç¬¦ï¼Œå®ƒå ç”¨ 4 ä¸ªå­—èŠ‚ï¼Œå…è®¸ä½¿ç”¨ ASCII ç ï¼Œä¸­æ–‡ï¼Œæ—¥è¯­ï¼ŒéŸ©è¯­ï¼Œemoji, zero-width spaces ç­‰ç­‰ã€‚
ä¸€ä¸ªå­—ç¬¦ä¸ç­‰äºä¸€ä¸ª Unicode

```rust
let c = '2';
let d: char = 'ç‹';
let e = 'ğŸ˜„';
```

### å…ƒç»„

å…ƒç»„çš„é•¿åº¦æ˜¯å›ºå®šä¸å˜çš„ï¼Œä¸å¯ä»¥ä¿®æ”¹ï¼Œä¾‹å¦‚ï¼š

```rust
    let t : (f32, f64, u32) = (500.0, 6.4, 1); // ä¸‰ä¸ªå…ƒç»„
let t1 = t.0; // é€šè¿‡æ•°å­—ä¸‹æ ‡æ¥è®¿é—®å…ƒç»„
let t2 = t.1;
let t3 = t.2;

println!("t: {t1}");
println!("t: {}", t.2);

let t : (f32, f64, u32, u64) = (500.0, 6.4, 1, 64); // å››ä¸ªå…ƒç»„
let t1 = t.0;
let t2 = t.1;
let t3: u32 = t.2;
let t3: u64 = t.3;

let t2 : (f32) = (500.0); // ä¸€ä¸ªä¹Ÿèƒ½ç»„æˆå…ƒç»„

let t3 = (500.0, 6.4, 1, 64); // ä¸å†™ç±»å‹ çš„è¯ä¼šè‡ªåŠ¨ä½¿ç”¨é»˜è®¤çš„åŸºæœ¬ç±»å‹
```


### æ•°ç»„

æ•°ç»„ä¸å…ƒç»„ä¸åŒçš„æ˜¯ï¼Œæ•°ç»„é‡Œé¢çš„å…ƒç´ å¿…é¡»æ˜¯åŒä¸€ä¸ªç±»å‹ï¼Œä¾‹å¦‚ï¼š

```rust
let a: [i32; 4] = [1, 2, 3, 4]; // è¡¨ç¤ºä¸€ä¸ª int 32 ä½ï¼Œé•¿åº¦æ˜¯ 4 çš„æ•°ç»„
let a = [1, 2, 3, 4]; // ç®€å†™ï¼šè¡¨ç¤ºä¸€ä¸ª int 32 ä½ï¼Œé•¿åº¦æ˜¯ 4 çš„æ•°ç»„
let a = [4; 5]; // ç®€å†™ [value; length] ï¼šè¡¨ç¤ºä¸€ä¸ª int 32 ä½ï¼Œé•¿åº¦æ˜¯ 5ï¼Œ å¹¶ä¸”æ¯ä¸€ä¸ªæ•°å­—éƒ½æ˜¯ 4
let size = a.len();
println!("{}, {size}", a[0]); // é€šè¿‡ä¸‹æ ‡è®¿é—®æŸä¸ªå…ƒç´ 
```


## å‡½æ•°


```rust
fn main() {
    another_function();
}

fn another_function() {
    // å¦å¤–ä¸€ä¸ªå‡½æ•°ï¼Œå‡½æ•°å‘½åéµå¾ªä½¿ç”¨ä¸‹åˆ’çº¿å‘½åæ–¹æ³•
    println!("Call another function!!")
}


// ä¼ å‚æ•°
fn main() {
let a = 10;
let b = 30.0;
print_params(a, b);
}

fn print_params(x: i32, y: f64){
    println!("x {x} y:{y}");
}
```

### è¿”å›å€¼

å‡½æ•°å¦‚æœæœ‰è¿”å›å€¼ï¼Œå¿…é¡»ä½¿ç”¨ -> ç±»å‹æ¥å£°æ˜ï¼Œä¾‹å¦‚ -> i32, è¿”å›æ—¶ï¼Œé€šå¸¸ä½¿ç”¨æœ€åä¸€ä¸ªå€¼ä½œä¸ºè¿”å›å€¼ï¼Œ
ä¹Ÿå¯æ˜¯ä½¿ç”¨ return æ¥æå‰è¿”å›

```rust

fn five() -> i32 {
    5
}

fn main() {
    let x = five();
    println!("The value of x is: {x}");
}

fn test_return() {
    return 10; // æŠ¥é”™ï¼Œå‡½æ•°æ²¡æœ‰å£°æ˜è¿”å›ï¼Œå‡½æ•°çš„è¿”å›å€¼ä¸èƒ½ç›´æ¥æ¨å¯¼å‡ºæ¥
}

fn test_return() -> i32 {
    10; // æŠ¥é”™ï¼Œrust æ˜¯è¡¨è¾¾å¼è¯­è¨€ï¼Œæœ€åä¸€ä¸ªå€¼ä¸èƒ½åŠ ä¸Šï¼›åˆ†å·
}
```

### è¯­å¥ä¸è¡¨è¾¾å¼

Rust æ˜¯ä»¥è¡¨è¾¾å¼ä¸ºåŸºç¡€çš„ï¼Œè¯­å¥ä¼šè¿”å›å€¼ï¼Œä½†æ˜¯è¡¨è¾¾å¼ä¸ä¼šï¼Œä¸¾ä¾‹å­:

```rust
// åŒºåˆ« 1
let a = b = 5; // æŠ¥é”™ï¼Œåœ¨è¯­å¥ä¸­å¯ä»¥ï¼Œä½†æ˜¯åœ¨è¡¨è¾¾å¼ä¸­ï¼Œ b = 5 ä¸ä¼šè¿”å›ä»»ä½•å€¼

// åŒºåˆ« 2
let mut a = 10;
let b = { // æ³¨æ„æ­¤æ—¶ b æ²¡æœ‰ä»»ä½•ç±»å‹
    a = 100;
    a + 10; // æœ«å°¾åŠ ä¸Šäº†åˆ†å·ï¼Œåˆ™æ²¡æœ‰è¿”å›ä»»ä½•æ•°æ®
};
let b = {
    a = 100;
    a + 10 // æ²¡æœ‰åŠ åˆ†å·ï¼Œåˆ™è¿™ä¸ªå€¼å°±æ˜¯ b çš„å€¼
};
println!("{b}");
```

## æ§åˆ¶æµ

æ¡ä»¶è¯­å¥ if, æ³¨æ„ åœ¨æ¡ä»¶åˆ¤æ–­ä¸­ï¼Œ else if ä¸  else éƒ½æ˜¯å¯é€‰çš„

```rust
let a = 10;
if a == 10 { // if
    println!("true");
} else if a > 10 { // else if
    println!("20")
} else { // else
    println!("30")
}
let b = if a == 10 { 2 } else { 30 };
```

#### å¾ªç¯

å¾ªç¯æœ‰ loop, for å’Œ while, loop ç±»ä¼¼äº do .. while:

```rust
loop { // ç±»ä¼¼äº do .. while
    println!("100");
    break;
}


let a  = loop { // ç±»ä¼¼äº do .. while
    println!("100");
    break 10; // æ„æ€æ˜¯è¿”å›æœ€åè¿”å›ä¸€ä¸ª 10
};
```


ç»™ loop æ·»åŠ  label,ä½¿ç”¨ continue æˆ– break çš„æ—¶å€™ï¼Œèƒ½æŒ‡å®šå®ƒï¼š

```rust
fn main() {
    let mut count = 0;
    'counting_up: loop { // ç»™å¤–å±‚çš„ loop å¢åŠ äº†ä¸€ä¸ªæ ‡è®° label
        println!("count = {count}");
        let mut remaining = 10;

        loop {
            println!("remaining = {remaining}");
            if remaining == 9 {
                break; // è¿™é‡Œæ‰“æ–­çš„æ˜¯æœ€è¿‘çš„é‚£ä¸ªå¾ªç¯ï¼Œæœ€æ¥è¿‘å½“å‰è¯­å¥æ˜¯å¾—é‡Œé¢çš„ loop
            }
            if count == 2 {
                break 'counting_up; // æ‰“æ–­æŒ‡å®šçš„ loop
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("End count = {count}");
}
```

#### while
```rust
fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index < 5 {
        println!("the value is: {}", a[index]);

        index += 1;
    }
}
```

#### for
```rust
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("the value is: {element}");
    }
}
fn main() {
    for number in (1..4).rev() {
        println!("{number}!");
    }
    println!("LIFTOFF!!!");
}
```

## Ownership: æ‰€æœ‰æƒ

### stack ä¸ heap

stack ç¬¦åˆåè¿›å…ˆå‡ºçš„åŸåˆ™ï¼Œç±»ä¼¼äºè·Œç›˜å­ï¼Œæ”¾åˆ°è¿™é‡Œçš„æ•°æ®å¿…é¡»æ˜¯å›ºå®šçš„é•¿åº¦<br>
heap éœ€è¦å…ˆæ‰¾åˆ°ä¸€å—åˆé€‚çš„å†…å­˜ç©ºé—´ï¼Œç„¶ååœ¨ç”³è¯·æŒ‡å®šçš„å¤§å°<br>


ä¸‹é¢ä¾‹å­ä¸­ï¼Œå­—é¢é‡ &str å°±æ˜¯åˆ†é…åœ¨ stack ä¸­ï¼Œå®ƒçš„å¤§å°æ˜¯å¯ä»¥é¢„çŸ¥çš„ï¼Œ String å°±æ˜¯åˆ†é…åœ¨ heap ä¸­çš„,
å› ä¸ºå®ƒå¯ä»¥éšæ—¶ä¿®æ”¹

```rust
// å­—é¢é‡ï¼šå­—é¢é‡æ˜¯ä¸å¯ä»¥ä¿®æ”¹çš„
let mut a = "1234"; // &str  å­—é¢é‡
let b = a;
a = "456";
println!("{}, {}", a, b); // è¾“å‡º 456ï¼Œ 1234

// String ä¸å­—é¢é‡ä¸åŒï¼ŒString æ˜¯å¯ä»¥ä¿®æ”¹çš„
let mut a = String::from("1234"); // String
a.push_str(" 567");
println!("{}",a); // è¾“å‡º 1234 567ï¼Œ String æ˜¯å¯ä»¥ä¿®æ”¹çš„
```

æ‰€æœ‰çš„åŸºæœ¬ç±»å‹ä¸å­—é¢é‡ï¼Œ ä»…åŒ…å«åŸºæœ¬ç±»å‹çš„å…ƒç»„éƒ½ä¼šè¢«æ”¾åˆ° stack ä¸Šï¼Œå› ä¸ºå®ƒä»¬çš„å¤§å°æ˜¯ç¡®å®šçš„ï¼Œå…¶ä»–çš„ç±»å‹
åˆ™ä¼šæ”¾åˆ° heap å †ä¸­ã€‚

### æ‰€æœ‰æƒè§„åˆ™
1. æ¯ä¸ªå€¼éƒ½æœ‰ä¸”ä»…æœ‰ä¸€ä¸ª owner
2. åœ¨åŒä¸€ä¸ªæ—¶é—´ä¹Ÿä»…èƒ½æœ‰ä¸€ä¸ª owner
3. å½“ owner è¶…å‡ºèŒƒå›´ï¼Œå¯¹åº”çš„å€¼å°±ä¼šè¢«åˆ é™¤ drop

ä¸¾ä¸ªä¾‹å­ï¼š

```rust
let s1 = String::from("hello");
let s2 = s1; // æ ¹æ®è§„åˆ™ 1ï¼Œæ­¤æ—¶ hello å·²ç»æŠŠ hello æ‰€æœ‰æƒä» s1 äº¤ç»™äº† s2

// æ‰“å° s1 æ—¶ï¼Œ ä¼šæŠ¥é”™ï¼Œå› ä¸ºæ­¤æ—¶ s1 å·²ç»æŠŠå€¼å€Ÿç»™ s2 äº†
println!("{}, world!", s1);

```

è§£å†³æ–¹æ³•ï¼Œæ ¹æ®æŠ¥é”™ï¼š

```
   |
88 |     let s1 = String::from("abc"); // å¦‚æœs1 çš„ç±»å‹æ˜¯åŸºæœ¬ç±»å‹ï¼Œæˆ–è€…å®ç°äº†  `Copy` trait , åˆ™å®ç°çš„æ˜¯æ‹·è´å€¼ï¼Œè€Œä¸æ˜¯åœ°å€
   |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
89 |     let s2 = s1;
   |              -- value moved here // å€¼è¢«ç§»åŠ¨äº†
90 |     println!("{}", s1);
   |                    ^^ value borrowed here after move // å€¼è¢«å€Ÿèµ°äº†ï¼Œæ‰€ä»¥ s1 æ­¤æ—¶æ²¡æœ‰å€¼ï¼Œæ— æ³•æ‰“å°
   |
   = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider cloning the value if the performance cost is acceptable
   |
89 |     let s2 = s1.clone(); // è§£å†³åŠæ³•ï¼Œå¯ä»¥ä½¿ç”¨æ‹·è´æ–¹æ³•ï¼Œæ˜ç¡®å‘Šè¯‰ç¼–è¯‘å™¨ï¼Œs2 è¦æ‹·è´å€¼
   |                ++++++++

```

å‰é¢è¯´äº†ï¼ŒåŸºæœ¬ç±»å‹ï¼Œå­—é¢é‡ï¼Œè¿›åŒ…å«åŸºæœ¬ç±»å‹çš„å…ƒç»„ï¼Œæˆ–è€…æ˜¯ å®ç°äº†  `Copy` trait çš„ç±»å‹ï¼Œèµ‹å€¼çš„æ—¶å€™ä¼šç›´æ¥å¤åˆ¶çš„ï¼Œå› ä¸ºä»–ä»¬çš„å¤§å°æ˜¯ç¡®å®šçš„ï¼Œ
è€Œä¸”éƒ½æ¯”è¾ƒç®€å•ï¼Œæ‰€ä»¥å¤åˆ¶æˆ–å¤„ç†ä»–ä»¬çš„æ•ˆç‡ä¹Ÿæ˜¯éå¸¸é«˜çš„ï¼Œå½“ç¼–è¯‘å™¨é‡åˆ°è¿™äº›ç±»å‹çš„æ—¶å€™ï¼Œä¼šé»˜è®¤é€‰æ‹©æ‹·è´å€¼è€Œä¸æ˜¯å€Ÿå€¼

å‡½æ•°ä¹Ÿè·Ÿå˜é‡æ˜¯ä¸€æ ·çš„ï¼š

```rust
fn main() {
    let s1 = String::from("ttt");
    borrow_value(s1);
    // println!("{}", s1);  æŠ¥é”™ï¼Œå› ä¸º s1 æŠŠå€¼å€Ÿç»™ å‡½æ•° borrow_value äº†
}

fn borrow_value(value: String) {
    println!("{}", value);
}
```

### å¼•ç”¨

å¼•ç”¨çš„å¥½å¤„æ˜¯ï¼Œå½“ä½¿ç”¨å¤æ‚å¯¹è±¡ä¼ é€’ç»™å‡½æ•°æ—¶ï¼Œå€Ÿå‡ºå»çš„å€¼å¾€å¾€éœ€è¦é€šè¿‡å…ƒç»„å…¨éƒ¨è¿”è¿˜å›æ¥ï¼Œä¸ç„¶å€Ÿå‡ºå»çš„å˜é‡ä¹‹åå°±æ— æ³•è®¿é—®äº†ã€‚<br>
ä¸ºäº†é¿å…è¿™ç§æƒ…å†µï¼Œå°±ä½¿ç”¨ & å¼•ç”¨æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼š

```rust
fn main() {
    let mut s = String::from("hello"); // s å¯å˜
    change(&s); // å¼•ç”¨ reference ä¼ é€’
    println!("{}", s); // s å¯æ‰“å°
}

fn change(some_string: &String) {
    // some_string ä¸å¯å˜ï¼Œå°½ç®¡ s æ˜¯å¯å˜çš„ï¼Œå› ä¸º some_string æ˜¯å¼•ç”¨
    some_string.push_str(", world"); // æŠ¥é”™ï¼ï¼ï¼
}
```

é»˜è®¤å¼•ç”¨æ˜¯ä¸å¯ä¿®æ”¹çš„ï¼Œå¦‚æœéœ€è¦ä¿®æ”¹ï¼Œå¯ä»¥å†™æˆ &mut xxx:

```rust
fn main() {
    let mut s = String::from("hello"); // s å¯å˜
    change(&mut s); // å¼•ç”¨ reference ä¼ é€’
    println!("{}", s); // s å¯æ‰“å°
}

fn change(some_string: &mut String) {
    some_string.push_str(", world"); // è¿™æ—¶å€™å°±å¯ä»¥ä¿®æ”¹äº†
}
```

æ³¨æ„ï¼Œå¼•ç”¨ä¼ é€’åœ¨ä¸€ä¸ªèŒƒå›´å†…åªèƒ½ä¼ é€’ä¸€æ¬¡ï¼Œä¾‹å¦‚ï¼š

```rust
let mut s = String::from("hello"); // s å¯å˜
let mut s1 = &mut s;
let mut s2 = &mut s;
println!("{}", s1); // æŠ¥é”™ï¼Œå› ä¸º s åˆå€Ÿç»™äº†s2, æ‰€ä»¥ s1 æ²¡æœ‰å€¼
println!("{}", s2); // æ­£ç¡®ï¼Œæœ€åä¸€ä¸ªå¼•ç”¨å¯ä»¥è®¿é—®å€¼
```


æŠ¥é”™å¦‚ä¸‹ï¼š

```
    |
102 |     let mut s1 = &mut s;
    |                  ------ first mutable borrow occurs here
103 |     let mut s2 = &mut s;
    |                  ^^^^^^ second mutable borrow occurs here
104 |     println!("{}", s1); // æŠ¥é”™ï¼Œå› ä¸º s åˆå€Ÿç»™äº†s2, æ‰€ä»¥ s1 æ²¡æœ‰å€¼
    |                    -- first borrow later used here
```


åŒæ—¶ï¼Œrust ç¦æ­¢ä¸€ä¸ªå˜é‡åœ¨åŒä¸€ä¸ªèŒƒå›´ï¼Œæˆ–åŒä¸€ä¸ªæ—¶é—´å†…ï¼Œæœ‰å¯å˜çš„å’Œä¸å¯å˜çš„ä¸¤ç§å¼•ç”¨ï¼Œä¾‹å¦‚ï¼š

```rust
let mut s = String::from("hello"); // s å¯å˜
let mut s1 = &s; // ä¸å¯å˜å¼•ç”¨ &s
let mut s2 = &s; // ä¸å¯å˜å¼•ç”¨ &s
let mut s3 = &mut s; // å¯å˜å¼•ç”¨ &mut s
println!("{} {} {}", s1, s2, s3);
```


#### æ‚¬åœæŒ‡é’ˆ Dangling References

å¼•ç”¨ä¸èƒ½è¶…è¿‡å®ƒè‡ªå·±çš„ç”Ÿå‘½å‘¨æœŸï¼Œä¾‹å¦‚ï¼š

```rust
fn dangle() -> &String { // è¿”å›æ—¶æŠ¥é”™ï¼Œæç¤ºï¼šMissing lifetime specifier [E0106]
    let s = String::from("1234");
    &s
}

//è§£æï¼š
fn dangle() -> &String { // dangle returns a reference to a String

    let s = String::from("hello"); // s is a new String

    &s // we return a reference to the String, s
} // Here, s goes out of scope, and is dropped. Its memory goes away.
// Danger!

fn dangle(t: &String) -> &String {
    let s = String::from("1234");
    &s // åŠ ä¸Šå‚æ•°ç¼–è¯‘æ—¶æŠ¥é”™ï¼š^^ returns a reference to data owned by the current function
}
```

&s è¶…å‡ºäº†è‡ªå·±çš„ç”Ÿå‘½å‘¨æœŸï¼Œå¯¼è‡´æ— æ³•ç¼–è¯‘é€šè¿‡

```rust
fn dangle(t: &String) -> &String {
    let s = String::from("1234");
    &t // è¿™æ˜¯å¯ä»¥çš„ï¼Œè¿”å›çš„ &t å¼•ç”¨æ˜¯å¤–éƒ¨çš„ï¼Œæ²¡æœ‰è¶…å‡ºè‡ªå·±çš„ç”Ÿå‘½å‘¨æœŸ
}

fn dangle() -> String { // ç›´æ¥è¿”å›å˜é‡æœ¬èº«å³å¯
    let s = String::from("1234");
    s
}
```


## åˆ‡ç‰‡ slices
slice æ˜¯ reference çš„ä¸€éƒ¨é—¨ï¼Œå­—é¢é‡ &str å°±æ˜¯åˆ‡ç‰‡ï¼Œè€ƒè™‘ä¸‹é¢çš„ä»£ç ï¼š

```rust
fn first_word(s: &String) -> usize {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s); // word will get the value 5

    s.clear(); // this empties the String, making it equal to ""
    
    println!("{}", word);
    // word still has the value 5 here, but there's no more string that
    // we could meaningfully use the value 5 with. word is now totally invalid!
}
```

ä¸Šé¢çš„ä¾‹å­ï¼Œå¦‚æœ s è¢«ä¿®æ”¹äº†ï¼Œä½†æ˜¯ word ä»ç„¶æ˜¯æŒ‡å‘ 5ï¼Œè¿™ä¸ªæ—¶å€™å·²ç»ä¸å¯¹äº†ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦ç”¨åˆ‡ç‰‡ï¼Œå¼•ç”¨å®ƒçš„ä¸€æ®µï¼Œå¦‚æœé‚£ä¸€æ®µå˜åŒ–äº†ï¼Œé‚£å®ƒä¹Ÿ
ä¼šè·Ÿç€å˜åŒ–ï¼Œä¾‹å¦‚ï¼š

```rust
let mut s = String::from("hello world");

let word = first_word(&s); // word will get the value 5
let hello = &s[0..5];
let world = &s[6..11];
println!("{} {} {}", word, hello, world);

s.clear(); // error, å› ä¸º s å·²ç»å€Ÿäº†ï¼Œæ‰€ä»¥æ— æ³•æ‰§è¡Œ clear æ“ä½œ
println!("{} {} {}",word, hello, world);
```
