# Rust å­¦ä¹ ç¬”è®°

## ç¼–è¯‘é…ç½®

### rust å‘½ä»¤

```shell
# æŸ¥çœ‹å½“å‰çš„ rust ç‰ˆæœ¬
rustc --version
# å‡çº§ rust 
rustc update
# ç¼–è¯‘ä¸€ä¸ª rust æ–‡ä»¶
rustc main.rs
# æŸ¥çœ‹ æ–‡æ¡£
rustup doc
```

### cargo å‘½ä»¤

```shell
# åˆ›å»ºä¸€ä¸ªé¡¹ç›®, hello-rust æ˜¯é¡¹ç›®åç§°ï¼Œé¡¹ç›®åç§°éµå¾ª xxx-xxx åŸåˆ™ï¼Œå­—æ¯éƒ½ç”¨å°å†™å­—æ¯ 
carg new hello-rust --vcs=git
# ç¼–è¯‘ä¸€ä¸ªé¡¹ç›®, ç¼–è¯‘ä¹‹åä¼šç”Ÿæˆä¸€ä¸ª debug çš„ç›®å½•ï¼Œè¿›å…¥è¯¥ç›®å½•ä¹‹åå°±å¯ä»¥è¿è¡Œ
# å¦‚æœéœ€è¦ç¼–è¯‘ release çš„ï¼Œå¯ä»¥ä½¿ç”¨ -help æŸ¥çœ‹å¸®åŠ©ï¼Œé»˜è®¤ç¼–è¯‘çš„æ˜¯ debug
cargo build
# è¿è¡Œä¸€ä¸ªé¡¹ç›®
cargo run 
# è¿è¡Œæ—¶æ£€æŸ¥ä¸€ä¸ªé¡¹ç›®æƒ…å†µ
# check å‘½ä»¤è¦æ¯” run å¿«ï¼Œå› ä¸ºå®ƒä¸éœ€è¦è¿è¡Œï¼Œå¦‚æœé¡¹ç›®éå¸¸å¤§ï¼Œéœ€è¦ç¼–è¯‘å¾ˆä¹…æ‰èƒ½è¿è¡Œï¼Œè€Œç¨å¾®æœ‰ç‚¹é”™è¯¯
# å°±ä¼šå¯¼è‡´è¿è¡Œå¤±è´¥ï¼Œä½¿ç”¨ run å‘½ä»¤å°±ä¼šè®©äººæŠ“ç‹‚ï¼Œcheck å‘½ä»¤å°±èƒ½æ”¹å–„è¿™ç§æƒ…å†µ
cargo check 
```

## é¡¹ç›®ç»“æ„

ä¸‹é¢å±•ç¤ºäº†ä¸€ä¸ªç®€å•çš„é¡¹ç›®ç»“æ„ï¼š<br>

```
.
â”œâ”€â”€ Cargo.lock // å½“å‰é¡¹ç›®ä¸ç¬¬ä¸‰æ–¹çš„ç‰ˆæœ¬é…ç½®ï¼Œé€šå¸¸è¿™ä¸ªä¹Ÿä¼šåŠ å…¥åˆ° git ç‰ˆæœ¬æ§åˆ¶ä¸­ï¼Œå› ä¸ºæœ‰çš„é¡¹ç›®å¯èƒ½éœ€è¦ç‰¹å®šçš„ç‰ˆæœ¬æ‰èƒ½ç¼–è¯‘
â”œâ”€â”€ Cargo.toml // å½“å‰é¡¹ç›®ä¸ç¬¬ä¸‰æ–¹çš„ç‰ˆæœ¬é…ç½®, ä¸ lock ä¸åŒï¼Œè¿™é‡Œæ˜¯é…ç½®çš„åœ°æ–¹
â”œâ”€â”€ readme.md // é¡¹ç›®è¯´æ˜
â”œâ”€â”€ src // é¡¹ç›®æºç å­˜æ”¾ä½ç½®
â”‚Â Â  â””â”€â”€ main.rs // é¡¹ç›®æºä»£ç 
â””â”€â”€ target // ç¼–è¯‘åçš„ç›®å½•å­˜æ”¾ä½ç½®ï¼Œé€šå¸¸è¯¥æ–‡ä»¶ä¸ä¼šåŠ å…¥åˆ° git ç‰ˆæœ¬æ§åˆ¶ä¸­
    â”œâ”€â”€ CACHEDIR.TAG 
    â””â”€â”€ debug // ä¸Šé¢æåˆ°çš„ cargo build åçš„äº§ç‰©å°±å­˜åœ¨å½“å‰ç›®å½•ä¸‹
        â”œâ”€â”€ build
        â”œâ”€â”€ deps
        â”œâ”€â”€ examples
        â””â”€â”€ incremental
```

### Cargo.toml é…ç½®æ–‡ä»¶è¯¦è§£

```toml
[package]
name = "hello_cargo" # å½“å‰é¡¹ç›®åç§°
version = "0.1.0" # å½“å‰é¡¹ç›®ç‰ˆæœ¬
edition = "2021" # ä¿®æ”¹æ—¶é—´

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
rand = "0.8.5" # è¡¨ç¤ºç”¨äº†ä¸€ä¸ª rand ç¬¬ä¸‰æ–¹åº“ï¼Œç‰ˆæœ¬æ˜¯ 0.8.5
# æ·»åŠ å®Œä¹‹åï¼Œä½¿ç”¨ cargo build å°±å¯ä»¥æŠŠè¯¥ç¬¬ä¸‰æ–¹çš„ä»¥åŠå®ƒå…³è”çš„ç¬¬ä¸‰æ–¹éƒ½æ‹‰ä¸‹æ¥ï¼Œå¹¶å­˜å‚¨åˆ° .lock æ–‡ä»¶ä¸­

# ä½¿ç”¨éå›ºå®šç‰ˆæœ¬
#rand = "^0.8.5" # è¡¨ç¤ºç”¨æœ€æ–°çš„0.8.x ç‰ˆæœ¬ï¼Œè¯¥ç‰ˆæœ¬å§‹ç»ˆå°äº 0.9.0 
#å‰é¢è¯´äº† .lock æ–‡ä»¶ä¼šå°†ç¬¬ä¸‰æ–¹ç‰ˆæœ¬ç‰ˆæœ¬é”å®šåœ¨æŸä¸ªç‰ˆæœ¬ï¼Œä¾‹å¦‚ 0.8.6ï¼Œ è¿‡äº†ä¸€æ®µæ—¶é—´åï¼Œè¯¥ç¬¬ä¸‰æ–¹åº“çš„ä½œè€…
#å‘å¸ƒäº† 0.8.7ï¼Œ é¡¹ç›®ä¸ä¼šè‡ªåŠ¨æ›´æ–°åˆ°è¯¥ç‰ˆæœ¬ï¼Œå°½ç®¡ä½¿ç”¨äº† ^, è¦æƒ³ä¸»åŠ¨æ›´æ–°ï¼Œå¯æ˜¯ä½¿ç”¨ï¼šcargo update æ¥æ›´æ–°
#æ³¨æ„ï¼Œå¦‚æœæœ‰æ›´æ–°ï¼Œä¼šåŒæ­¥æƒ³æ”¹ .lock æ–‡ä»¶é”å®šçš„ç‰ˆæœ¬
```

### Cargo.lock ç‰ˆæœ¬è¯¦è§£

è¯¥æ–‡ä»¶ä¸éœ€è¦æ‰‹åŠ¨ç¼–è¾‘ï¼Œä¼šè‡ªåŠ¨æ ¹æ®ç¯å¢ƒç”Ÿæˆï¼Œ

```toml
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 3

[[package]]
name = "hello_cargo" # é¡¹ç›®åç§°
version = "0.1.0" # é¡¹ç›®ç‰ˆæœ¬
dependencies = [ # å½“å‰é¡¹ç›®ä¾èµ–çš„ç¬¬ä¸‰æ–¹
 "rand",
]

[[package]]
name = "rand" # ä¾èµ–çš„ç¬¬ä¸‰æ–¹
version = "0.8.5" # ç‰ˆæœ¬
source = "registry+https://github.com/rust-lang/crates.io-index" # æºç åœ°å€
checksum = "34af8d1a0e25924bc5b7c43c079c942339d8f0a8b57c39049bef581b46327404"
dependencies = [ # è¯¥ç¬¬ä¸‰æ–¹åˆä¾èµ–äº†å…¶ä»–çš„ç¬¬ä¸‰æ–¹
    "libc",
    "rand_chacha",
    "rand_core",
]
#... è¿˜æœ‰å¾ˆå¤š ...
```

## ç¼–ç å‰æ

è¿™é‡Œè¯´ä¸€ä¸‹ç¼–ç çš„åŸºç¡€æƒ…å†µ

```rust
// ä½¿ç”¨  use å¯¼å…¥æŸä¸ªåŒ…ï¼Œ :: ä¸¤ä¸ªå†’å·æ¥è¡¨ç¤ºå¼•ç”¨æŸä¸ªç±»
use std::io;
fn main(){ // fn è¡¨ç¤ºå‡½æ•°ï¼Œ main() è¡¨ç¤ºé¡¹ç›®çš„å…¥å£
    let guess = "123";
    println!("You guessed: {guess}"); // println! è¾“å‡º, {} æ¥å¼•å…¥å˜é‡
    println!("You guessed: {}", guess); // ä¹Ÿå¯ä»¥è¿™ä¹ˆå†™

    io::stdin() // è¾“å…¥
        .read_line(&mut guess)
        .expect("Failed to read line"); // é”™è¯¯æ•æ‰

    let guess: u32 = match guess.trim().parse() { // é”™è¯¯æ•æ‰ è¿”å›ä¸€ä¸ª Ok ä¸ Err, Ok é‡Œé¢æœ‰æ­£ç¡®çš„å€¼
        Ok(num) => num, 
        Err(_) => println!("error"),
    };
}
```

## å˜é‡ä¸ç±»å‹

rust ç±»å‹ç¼–è¯‘çš„æ—¶å€™å°±å·²ç»ç¡®å®š

```rust
let x = 5; // ç¼–è¯‘å®šä¹‰äº†ä¸€ä¸ªå˜é‡ x çš„ç±»å‹æ˜¯ i32ï¼Œ ä¸»è¦è¯¥å˜é‡ x æ˜¯ä¸å¯ä»¥ä¿®æ”¹çš„

x = 10; // è¿™ä¸€è¡Œä»£ç ä¼šæŠ¥é”™ï¼Œåº”è¯¥é»˜è®¤çš„ x æ˜¯ä¸å¯ä»¥ä¿®æ”¹çš„

let mut y = 10; // ä½¿ç”¨ mut æ¥è¡¨ç¤º y æ˜¯å¯å˜çš„
y = 20; // å¯ä»¥æ­£ç¡®çš„ç¼–è¯‘

let mut y = "I am string!"; // ç±»å‹è¦†ç›–ï¼Œå¯ä»¥å°† y çš„ç±»å‹ä¿®æ”¹æ”¹æˆ String, è¿™æ˜¯è¿å…è®¸çš„
y = 20; // æŠ¥é”™ï¼ ä¿®æ”¹ä¹‹å y å°±æ˜¯ String ç±»å‹ï¼Œæ­¤æ—¶å†èµ‹å€¼æˆ i32 ç±»å‹å°±ä¼šæŠ¥é”™
y = "new String"; // æ­£ç¡®

// å¸¸é‡ï¼Œ æ³¨æ„å¸¸é‡ä¸å¯ä»¥è¢«è¦†ç›–
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
// let mut THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3; // æŠ¥é”™
// println!("new {THREE_HOURS_IN_SECONDS}");
//   |
// 8 |     const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
//   |     ------------------------------------------------ the constant `THREE_HOURS_IN_SECONDS` is defined here
// 9 |     let mut THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
//   |             ^^^^^^^^^^^^^^^^^^^^^^ cannot be named the same as a constant
```

### æ•´å‹

i è¡¨ç¤ºæœ‰ç¬¦å·ï¼ŒèŒƒå›´æ˜¯ï¼š-(2n - 1) to 2n - 1 - 1  u è¡¨ç¤ºæ— ç¬¦å·ï¼Œ èŒƒå›´æ˜¯ï¼š0 to 2n - 1 - 1

|Length	|Signed	|Unsigned|
| --- | --- | --- |
|8-bit	|i8	|u8|
|16-bit	|i16	|u16|
|32-bit	|i32	|u32|
|64-bit	|i64	|u64|
|128-bit	|i128	|u128|
|arch	|isize	|usize|

### æµ®ç‚¹å‹

æµ®ç‚¹å‹æ¯”è¾ƒç®€å•ï¼Œåªæœ‰ä¸¤ç§ç±»å‹ï¼Œåˆ†åˆ«æ˜¯ f32 å’Œ f64, é»˜è®¤ç±»å‹æ˜¯ f64, å› ä¸ºå¸‚é¢ä¸Šå¤§å¤šæ•°çš„æœºå™¨64 ä½èƒ½æœ‰ 32 ä½çš„è¿è¡Œæ€§èƒ½

### è®¡ç®—

è®¡ç®—æ”¯æŒåŸºæœ¬çš„åŠ å‡ä¹˜é™¤ä¸å–ä½™æ“ä½œï¼Œä½†æ˜¯ä¸æ”¯æŒä¸¤ä¸ªä¸åŒç±»å‹çš„ç›´æ¥è®¡ç®—ï¼Œä¾‹å¦‚ï¼š

```rust
let a = 10;
let b = 20.0;
let c = a * b; // æŠ¥é”™
//   |
//   |     let c = a * b;
//   |               ^ no implementation for `{integer} * {float}`
//   |
//   = help: the trait `Mul<{float}>` is not implemented for `{integer}`
```

### å¸ƒå°”ç±»å‹

```rust
let a = true;
let b: bool = false;
```

### char ç±»å‹

åªå…è®¸è®¾ç½®å•ä¸ªå­—ç¬¦ï¼Œå®ƒå ç”¨ 4 ä¸ªå­—èŠ‚ï¼Œå…è®¸ä½¿ç”¨ ASCII ç ï¼Œä¸­æ–‡ï¼Œæ—¥è¯­ï¼ŒéŸ©è¯­ï¼Œemoji, zero-width spaces ç­‰ç­‰ã€‚
ä¸€ä¸ªå­—ç¬¦ä¸ç­‰äºä¸€ä¸ª Unicode

```rust
let c = '2';
let d: char = 'ç‹';
let e = 'ğŸ˜„';
```

### å…ƒç»„

å…ƒç»„çš„é•¿åº¦æ˜¯å›ºå®šä¸å˜çš„ï¼Œä¸å¯ä»¥ä¿®æ”¹ï¼Œä¾‹å¦‚ï¼š

```rust
    let t : (f32, f64, u32) = (500.0, 6.4, 1); // ä¸‰ä¸ªå…ƒç»„
let t1 = t.0; // é€šè¿‡æ•°å­—ä¸‹æ ‡æ¥è®¿é—®å…ƒç»„
let t2 = t.1;
let t3 = t.2;

println!("t: {t1}");
println!("t: {}", t.2);

let t : (f32, f64, u32, u64) = (500.0, 6.4, 1, 64); // å››ä¸ªå…ƒç»„
let t1 = t.0;
let t2 = t.1;
let t3: u32 = t.2;
let t3: u64 = t.3;

let t2 : (f32) = (500.0); // ä¸€ä¸ªä¹Ÿèƒ½ç»„æˆå…ƒç»„

let t3 = (500.0, 6.4, 1, 64); // ä¸å†™ç±»å‹ çš„è¯ä¼šè‡ªåŠ¨ä½¿ç”¨é»˜è®¤çš„åŸºæœ¬ç±»å‹
```


### æ•°ç»„

æ•°ç»„ä¸å…ƒç»„ä¸åŒçš„æ˜¯ï¼Œæ•°ç»„é‡Œé¢çš„å…ƒç´ å¿…é¡»æ˜¯åŒä¸€ä¸ªç±»å‹ï¼Œä¾‹å¦‚ï¼š

```rust
let a: [i32; 4] = [1, 2, 3, 4]; // è¡¨ç¤ºä¸€ä¸ª int 32 ä½ï¼Œé•¿åº¦æ˜¯ 4 çš„æ•°ç»„
let a = [1, 2, 3, 4]; // ç®€å†™ï¼šè¡¨ç¤ºä¸€ä¸ª int 32 ä½ï¼Œé•¿åº¦æ˜¯ 4 çš„æ•°ç»„
let a = [4; 5]; // ç®€å†™ [value; length] ï¼šè¡¨ç¤ºä¸€ä¸ª int 32 ä½ï¼Œé•¿åº¦æ˜¯ 5ï¼Œ å¹¶ä¸”æ¯ä¸€ä¸ªæ•°å­—éƒ½æ˜¯ 4
let size = a.len();
println!("{}, {size}", a[0]); // é€šè¿‡ä¸‹æ ‡è®¿é—®æŸä¸ªå…ƒç´ 
```


## å‡½æ•°


```rust
fn main() {
    another_function();
}

fn another_function() {
    // å¦å¤–ä¸€ä¸ªå‡½æ•°ï¼Œå‡½æ•°å‘½åéµå¾ªä½¿ç”¨ä¸‹åˆ’çº¿å‘½åæ–¹æ³•
    println!("Call another function!!")
}


// ä¼ å‚æ•°
fn main() {
let a = 10;
let b = 30.0;
print_params(a, b);
}

fn print_params(x: i32, y: f64){
    println!("x {x} y:{y}");
}
```

### è¿”å›å€¼

å‡½æ•°å¦‚æœæœ‰è¿”å›å€¼ï¼Œå¿…é¡»ä½¿ç”¨ -> ç±»å‹æ¥å£°æ˜ï¼Œä¾‹å¦‚ -> i32, è¿”å›æ—¶ï¼Œé€šå¸¸ä½¿ç”¨æœ€åä¸€ä¸ªå€¼ä½œä¸ºè¿”å›å€¼ï¼Œ
ä¹Ÿå¯æ˜¯ä½¿ç”¨ return æ¥æå‰è¿”å›

```rust

fn five() -> i32 {
    5
}

fn main() {
    let x = five();
    println!("The value of x is: {x}");
}

fn test_return() {
    return 10; // æŠ¥é”™ï¼Œå‡½æ•°æ²¡æœ‰å£°æ˜è¿”å›ï¼Œå‡½æ•°çš„è¿”å›å€¼ä¸èƒ½ç›´æ¥æ¨å¯¼å‡ºæ¥
}

fn test_return() -> i32 {
    10; // æŠ¥é”™ï¼Œrust æ˜¯è¡¨è¾¾å¼è¯­è¨€ï¼Œæœ€åä¸€ä¸ªå€¼ä¸èƒ½åŠ ä¸Šï¼›åˆ†å·
}
```

### è¯­å¥ä¸è¡¨è¾¾å¼

Rust æ˜¯ä»¥è¡¨è¾¾å¼ä¸ºåŸºç¡€çš„ï¼Œè¯­å¥ä¼šè¿”å›å€¼ï¼Œä½†æ˜¯è¡¨è¾¾å¼ä¸ä¼šï¼Œä¸¾ä¾‹å­:

```rust
// åŒºåˆ« 1
let a = b = 5; // æŠ¥é”™ï¼Œåœ¨è¯­å¥ä¸­å¯ä»¥ï¼Œä½†æ˜¯åœ¨è¡¨è¾¾å¼ä¸­ï¼Œ b = 5 ä¸ä¼šè¿”å›ä»»ä½•å€¼

// åŒºåˆ« 2
let mut a = 10;
let b = { // æ³¨æ„æ­¤æ—¶ b æ²¡æœ‰ä»»ä½•ç±»å‹
    a = 100;
    a + 10; // æœ«å°¾åŠ ä¸Šäº†åˆ†å·ï¼Œåˆ™æ²¡æœ‰è¿”å›ä»»ä½•æ•°æ®
};
let b = {
    a = 100;
    a + 10 // æ²¡æœ‰åŠ åˆ†å·ï¼Œåˆ™è¿™ä¸ªå€¼å°±æ˜¯ b çš„å€¼
};
println!("{b}");
```

## æ§åˆ¶æµ

### if

æ¡ä»¶è¯­å¥ if, æ³¨æ„ åœ¨æ¡ä»¶åˆ¤æ–­ä¸­ï¼Œ else if ä¸  else éƒ½æ˜¯å¯é€‰çš„

```rust
let a = 10;
if a == 10 { // if
    println!("true");
} else if a > 10 { // else if
    println!("20")
} else { // else
    println!("30")
}
let b = if a == 10 { 2 } else { 30 };
```

if let è¯­å¥ï¼Œå¯ä»¥æŠŠæšä¸¾é‡Œçš„å€¼è§£æ„å‡ºæ¥ï¼Œä¾‹å¦‚ï¼š

```rust
let some_option: Option<i32> = Some(42);
// ä½¿ç”¨ if let è§£æ„ Option æšä¸¾
if let Some(number) = some_option {
    println!("Option contains the value: {}", number);
} 
```

### å¾ªç¯ loop

å¾ªç¯æœ‰ loop, for å’Œ while, loop ç±»ä¼¼äº do .. while:

```rust
loop { // ç±»ä¼¼äº do .. while
    println!("100");
    break;
}


let a  = loop { // ç±»ä¼¼äº do .. while
    println!("100");
    break 10; // æ„æ€æ˜¯è¿”å›æœ€åè¿”å›ä¸€ä¸ª 10
};
```


ç»™ loop æ·»åŠ  label,ä½¿ç”¨ continue æˆ– break çš„æ—¶å€™ï¼Œèƒ½æŒ‡å®šå®ƒï¼š

```rust
fn main() {
    let mut count = 0;
    'counting_up: loop { // ç»™å¤–å±‚çš„ loop å¢åŠ äº†ä¸€ä¸ªæ ‡è®° label
        println!("count = {count}");
        let mut remaining = 10;

        loop {
            println!("remaining = {remaining}");
            if remaining == 9 {
                break; // è¿™é‡Œæ‰“æ–­çš„æ˜¯æœ€è¿‘çš„é‚£ä¸ªå¾ªç¯ï¼Œæœ€æ¥è¿‘å½“å‰è¯­å¥æ˜¯å¾—é‡Œé¢çš„ loop
            }
            if count == 2 {
                break 'counting_up; // æ‰“æ–­æŒ‡å®šçš„ loop
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("End count = {count}");
}
```

### while
```rust
fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index < 5 {
        println!("the value is: {}", a[index]);

        index += 1;
    }
}
```

### for
```rust
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("the value is: {element}");
    }
}
fn main() {
    for number in (1..4).rev() {
        println!("{number}!");
    }
    println!("LIFTOFF!!!");
}
```

### match

ç±»ä¼¼äº java çš„ switchï¼Œæˆ–è€… kotlin çš„ whenï¼Œæ¯”è¾ƒæ¥è¿‘ kotlin çš„ whenï¼Œå…±åŒç‚¹ï¼š<br>

* å¯ä»¥æ˜¯ä»»æ„çš„ key
* å¿…é¡»ç©·ä¸¾æ‰€æœ‰çš„æ¡ä»¶
* å¯ä»¥äº§ç”Ÿè¿”å›å€¼

```rust
    let b = 100;
    let a = match b {
        10 => 2,
        20 => 30,
        other => 100,
    };
    println!("{a}");
```


## Ownership: æ‰€æœ‰æƒ

### stack ä¸ heap

stack ç¬¦åˆåè¿›å…ˆå‡ºçš„åŸåˆ™ï¼Œç±»ä¼¼äºè·Œç›˜å­ï¼Œæ”¾åˆ°è¿™é‡Œçš„æ•°æ®å¿…é¡»æ˜¯å›ºå®šçš„é•¿åº¦<br>
heap éœ€è¦å…ˆæ‰¾åˆ°ä¸€å—åˆé€‚çš„å†…å­˜ç©ºé—´ï¼Œç„¶ååœ¨ç”³è¯·æŒ‡å®šçš„å¤§å°<br>


ä¸‹é¢ä¾‹å­ä¸­ï¼Œå­—é¢é‡ &str å°±æ˜¯åˆ†é…åœ¨ stack ä¸­ï¼Œå®ƒçš„å¤§å°æ˜¯å¯ä»¥é¢„çŸ¥çš„ï¼Œ String å°±æ˜¯åˆ†é…åœ¨ heap ä¸­çš„,
å› ä¸ºå®ƒå¯ä»¥éšæ—¶ä¿®æ”¹

```rust
// å­—é¢é‡ï¼šå­—é¢é‡æ˜¯ä¸å¯ä»¥ä¿®æ”¹çš„
let mut a = "1234"; // &str  å­—é¢é‡
let b = a;
a = "456";
println!("{}, {}", a, b); // è¾“å‡º 456ï¼Œ 1234

// String ä¸å­—é¢é‡ä¸åŒï¼ŒString æ˜¯å¯ä»¥ä¿®æ”¹çš„
let mut a = String::from("1234"); // String
a.push_str(" 567");
println!("{}",a); // è¾“å‡º 1234 567ï¼Œ String æ˜¯å¯ä»¥ä¿®æ”¹çš„
```

æ‰€æœ‰çš„åŸºæœ¬ç±»å‹ä¸å­—é¢é‡ï¼Œ ä»…åŒ…å«åŸºæœ¬ç±»å‹çš„å…ƒç»„éƒ½ä¼šè¢«æ”¾åˆ° stack ä¸Šï¼Œå› ä¸ºå®ƒä»¬çš„å¤§å°æ˜¯ç¡®å®šçš„ï¼Œå…¶ä»–çš„ç±»å‹
åˆ™ä¼šæ”¾åˆ° heap å †ä¸­ã€‚

### æ‰€æœ‰æƒè§„åˆ™
1. æ¯ä¸ªå€¼éƒ½æœ‰ä¸”ä»…æœ‰ä¸€ä¸ª owner
2. åœ¨åŒä¸€ä¸ªæ—¶é—´ä¹Ÿä»…èƒ½æœ‰ä¸€ä¸ª owner
3. å½“ owner è¶…å‡ºèŒƒå›´ï¼Œå¯¹åº”çš„å€¼å°±ä¼šè¢«åˆ é™¤ drop

ä¸¾ä¸ªä¾‹å­ï¼š

```rust
let s1 = String::from("hello");
let s2 = s1; // æ ¹æ®è§„åˆ™ 1ï¼Œæ­¤æ—¶ hello å·²ç»æŠŠ hello æ‰€æœ‰æƒä» s1 äº¤ç»™äº† s2

// æ‰“å° s1 æ—¶ï¼Œ ä¼šæŠ¥é”™ï¼Œå› ä¸ºæ­¤æ—¶ s1 å·²ç»æŠŠå€¼å€Ÿç»™ s2 äº†
println!("{}, world!", s1);

```

è§£å†³æ–¹æ³•ï¼Œæ ¹æ®æŠ¥é”™ï¼š

```
   |
88 |     let s1 = String::from("abc"); // å¦‚æœs1 çš„ç±»å‹æ˜¯åŸºæœ¬ç±»å‹ï¼Œæˆ–è€…å®ç°äº†  `Copy` trait , åˆ™å®ç°çš„æ˜¯æ‹·è´å€¼ï¼Œè€Œä¸æ˜¯åœ°å€
   |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
89 |     let s2 = s1;
   |              -- value moved here // å€¼è¢«ç§»åŠ¨äº†
90 |     println!("{}", s1);
   |                    ^^ value borrowed here after move // å€¼è¢«å€Ÿèµ°äº†ï¼Œæ‰€ä»¥ s1 æ­¤æ—¶æ²¡æœ‰å€¼ï¼Œæ— æ³•æ‰“å°
   |
   = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider cloning the value if the performance cost is acceptable
   |
89 |     let s2 = s1.clone(); // è§£å†³åŠæ³•ï¼Œå¯ä»¥ä½¿ç”¨æ‹·è´æ–¹æ³•ï¼Œæ˜ç¡®å‘Šè¯‰ç¼–è¯‘å™¨ï¼Œs2 è¦æ‹·è´å€¼
   |                ++++++++

```

å‰é¢è¯´äº†ï¼ŒåŸºæœ¬ç±»å‹ï¼Œå­—é¢é‡ï¼Œè¿›åŒ…å«åŸºæœ¬ç±»å‹çš„å…ƒç»„ï¼Œæˆ–è€…æ˜¯ å®ç°äº†  `Copy` trait çš„ç±»å‹ï¼Œèµ‹å€¼çš„æ—¶å€™ä¼šç›´æ¥å¤åˆ¶çš„ï¼Œå› ä¸ºä»–ä»¬çš„å¤§å°æ˜¯ç¡®å®šçš„ï¼Œ
è€Œä¸”éƒ½æ¯”è¾ƒç®€å•ï¼Œæ‰€ä»¥å¤åˆ¶æˆ–å¤„ç†ä»–ä»¬çš„æ•ˆç‡ä¹Ÿæ˜¯éå¸¸é«˜çš„ï¼Œå½“ç¼–è¯‘å™¨é‡åˆ°è¿™äº›ç±»å‹çš„æ—¶å€™ï¼Œä¼šé»˜è®¤é€‰æ‹©æ‹·è´å€¼è€Œä¸æ˜¯å€Ÿå€¼

å‡½æ•°ä¹Ÿè·Ÿå˜é‡æ˜¯ä¸€æ ·çš„ï¼š

```rust
fn main() {
    let s1 = String::from("ttt");
    borrow_value(s1);
    // println!("{}", s1);  æŠ¥é”™ï¼Œå› ä¸º s1 æŠŠå€¼å€Ÿç»™ å‡½æ•° borrow_value äº†
}

fn borrow_value(value: String) {
    println!("{}", value);
}
```

### å¼•ç”¨

å¼•ç”¨çš„å¥½å¤„æ˜¯ï¼Œå½“ä½¿ç”¨å¤æ‚å¯¹è±¡ä¼ é€’ç»™å‡½æ•°æ—¶ï¼Œå€Ÿå‡ºå»çš„å€¼å¾€å¾€éœ€è¦é€šè¿‡å…ƒç»„å…¨éƒ¨è¿”è¿˜å›æ¥ï¼Œä¸ç„¶å€Ÿå‡ºå»çš„å˜é‡ä¹‹åå°±æ— æ³•è®¿é—®äº†ã€‚<br>
ä¸ºäº†é¿å…è¿™ç§æƒ…å†µï¼Œå°±ä½¿ç”¨ & å¼•ç”¨æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼š

```rust
fn main() {
    let mut s = String::from("hello"); // s å¯å˜
    change(&s); // å¼•ç”¨ reference ä¼ é€’
    println!("{}", s); // s å¯æ‰“å°
}

fn change(some_string: &String) {
    // some_string ä¸å¯å˜ï¼Œå°½ç®¡ s æ˜¯å¯å˜çš„ï¼Œå› ä¸º some_string æ˜¯å¼•ç”¨
    some_string.push_str(", world"); // æŠ¥é”™ï¼ï¼ï¼
}
```

é»˜è®¤å¼•ç”¨æ˜¯ä¸å¯ä¿®æ”¹çš„ï¼Œå¦‚æœéœ€è¦ä¿®æ”¹ï¼Œå¯ä»¥å†™æˆ &mut xxx:

```rust
fn main() {
    let mut s = String::from("hello"); // s å¯å˜
    change(&mut s); // å¼•ç”¨ reference ä¼ é€’
    println!("{}", s); // s å¯æ‰“å°
}

fn change(some_string: &mut String) {
    some_string.push_str(", world"); // è¿™æ—¶å€™å°±å¯ä»¥ä¿®æ”¹äº†
}
```

æ³¨æ„ï¼Œå¼•ç”¨ä¼ é€’åœ¨ä¸€ä¸ªèŒƒå›´å†…åªèƒ½ä¼ é€’ä¸€æ¬¡ï¼Œä¾‹å¦‚ï¼š

```rust
let mut s = String::from("hello"); // s å¯å˜
let mut s1 = &mut s;
let mut s2 = &mut s;
println!("{}", s1); // æŠ¥é”™ï¼Œå› ä¸º s åˆå€Ÿç»™äº†s2, æ‰€ä»¥ s1 æ²¡æœ‰å€¼
println!("{}", s2); // æ­£ç¡®ï¼Œæœ€åä¸€ä¸ªå¼•ç”¨å¯ä»¥è®¿é—®å€¼
```


æŠ¥é”™å¦‚ä¸‹ï¼š

```
    |
102 |     let mut s1 = &mut s;
    |                  ------ first mutable borrow occurs here
103 |     let mut s2 = &mut s;
    |                  ^^^^^^ second mutable borrow occurs here
104 |     println!("{}", s1); // æŠ¥é”™ï¼Œå› ä¸º s åˆå€Ÿç»™äº†s2, æ‰€ä»¥ s1 æ²¡æœ‰å€¼
    |                    -- first borrow later used here
```


åŒæ—¶ï¼Œrust ç¦æ­¢ä¸€ä¸ªå˜é‡åœ¨åŒä¸€ä¸ªèŒƒå›´ï¼Œæˆ–åŒä¸€ä¸ªæ—¶é—´å†…ï¼Œæœ‰å¯å˜çš„å’Œä¸å¯å˜çš„ä¸¤ç§å¼•ç”¨ï¼Œä¾‹å¦‚ï¼š

```rust
let mut s = String::from("hello"); // s å¯å˜
let mut s1 = &s; // ä¸å¯å˜å¼•ç”¨ &s
let mut s2 = &s; // ä¸å¯å˜å¼•ç”¨ &s
let mut s3 = &mut s; // å¯å˜å¼•ç”¨ &mut s
println!("{} {} {}", s1, s2, s3);
```

#### è§£é™¤å¼•ç”¨ * 

```rust
fn main() {
let mut x: Box<i32> = Box::new(1);
let a: i32 = *x;         // *x reads the heap value, so a = 1
*x += 1;                 // *x on the left-side modifies the heap value, 
                         //     so x points to the value 2

let r1: &Box<i32> = &x;  // r1 points to x on the stack
let b: i32 = **r1;       // two dereferences get us to the heap value

let r2: &i32 = &*x;      // r2 points to the heap value directly
let c: i32 = *r2;    // so only one dereference is needed to read it
}
```

![å †æ ˆæƒ…å†µ](./images/img.png)

é¦–å…ˆï¼š
1. a ç›´æ¥è¯»å–äº† heap ä¸­çš„ valueï¼Œæ‰€ä»¥ a = 1
2. *xå¯ä»¥ç›´æ¥ä¿®æ”¹ heap
3. r1 æ‹¿åˆ°çš„ x çš„å¼•ç”¨ï¼Œæ‰€ä»¥ r1 = &x
4. b é€šè¿‡ *r1 è®¿é—® r1 heap ä¸­çš„ valueï¼Œæ­¤æ—¶è¯¥ value æ˜¯ r1 æœ¬èº«ï¼Œæ¥ç€å†é€šè¿‡ *(*r1) æ‹¿åˆ°äº† r1 heap ä¸­çš„ value, æ‰€ä»¥æ­¤æ—¶ b = 2
5. r2 é€šè¿‡ *x è®¿é—® x heap ä¸­çš„ value, æ­¤æ—¶è¯¥ value å°±æ˜¯ 2ï¼Œæ¥ç€å†é€šè¿‡ &(*x) æ‹¿åˆ° 2 æ‰€åœ¨çš„ heapï¼Œæ‰€ä»¥æ­¤æ—¶ r2 = &i32 = heap 2
6. c é€šè¿‡ *r2 è®¿é—® r2 ä¸­çš„ valueï¼Œå³ c = 2

#### æ‚¬åœæŒ‡é’ˆ Dangling References

å¼•ç”¨ä¸èƒ½è¶…è¿‡å®ƒè‡ªå·±çš„ç”Ÿå‘½å‘¨æœŸï¼Œä¾‹å¦‚ï¼š

```rust
fn dangle() -> &String { // è¿”å›æ—¶æŠ¥é”™ï¼Œæç¤ºï¼šMissing lifetime specifier [E0106]
    let s = String::from("1234");
    &s
}

//è§£æï¼š
fn dangle() -> &String { // dangle returns a reference to a String

    let s = String::from("hello"); // s is a new String

    &s // we return a reference to the String, s
} // Here, s goes out of scope, and is dropped. Its memory goes away.
// Danger!

fn dangle(t: &String) -> &String {
    let s = String::from("1234");
    &s // åŠ ä¸Šå‚æ•°ç¼–è¯‘æ—¶æŠ¥é”™ï¼š^^ returns a reference to data owned by the current function
}
```

&s è¶…å‡ºäº†è‡ªå·±çš„ç”Ÿå‘½å‘¨æœŸï¼Œå¯¼è‡´æ— æ³•ç¼–è¯‘é€šè¿‡

```rust
fn dangle(t: &String) -> &String {
    let s = String::from("1234");
    &t // è¿™æ˜¯å¯ä»¥çš„ï¼Œè¿”å›çš„ &t å¼•ç”¨æ˜¯å¤–éƒ¨çš„ï¼Œæ²¡æœ‰è¶…å‡ºè‡ªå·±çš„ç”Ÿå‘½å‘¨æœŸ
}

fn dangle() -> String { // ç›´æ¥è¿”å›å˜é‡æœ¬èº«å³å¯
    let s = String::from("1234");
    s
}
```


## åˆ‡ç‰‡ slices
slice æ˜¯ reference çš„ä¸€éƒ¨é—¨ï¼Œå­—é¢é‡ &str å°±æ˜¯åˆ‡ç‰‡ï¼Œè€ƒè™‘ä¸‹é¢çš„ä»£ç ï¼š

```rust
fn first_word(s: &String) -> usize {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s); // word will get the value 5

    s.clear(); // this empties the String, making it equal to ""
    
    println!("{}", word);
    // word still has the value 5 here, but there's no more string that
    // we could meaningfully use the value 5 with. word is now totally invalid!
}
```

ä¸Šé¢çš„ä¾‹å­ï¼Œå¦‚æœ s è¢«ä¿®æ”¹äº†ï¼Œä½†æ˜¯ word ä»ç„¶æ˜¯æŒ‡å‘ 5ï¼Œè¿™ä¸ªæ—¶å€™å·²ç»ä¸å¯¹äº†ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦ç”¨åˆ‡ç‰‡ï¼Œå¼•ç”¨å®ƒçš„ä¸€æ®µï¼Œå¦‚æœé‚£ä¸€æ®µå˜åŒ–äº†ï¼Œé‚£å®ƒä¹Ÿ
ä¼šè·Ÿç€å˜åŒ–ï¼Œä¾‹å¦‚ï¼š

```rust
let mut s = String::from("hello world");

let word = first_word(&s); // word will get the value 5
let hello = &s[0..5];
let world = &s[6..11];
println!("{} {} {}", word, hello, world);

s.clear(); // error, å› ä¸º s å·²ç»å€Ÿäº†ï¼Œæ‰€ä»¥æ— æ³•æ‰§è¡Œ clear æ“ä½œ
println!("{} {} {}",word, hello, world);
```

## ç»“æ„ä½“

ä½¿ç”¨ struct æ¥å®šä¹‰ä¸€ä¸ªç»“æ„ä½“:

```rust
fn main(){
    let mut user1 = User {
        id: 10,
        email_address: String::from("abc@gmail.com"), // å­—æ®µçš„é¡ºåºå¯ä»¥å’Œç»“æ„ä½“çš„é¡ºåºä¸åŒ
        name: String::from("William"),
        password: String::from("123455"),
    };

    user1.id = 20;
    println!("{}", user1.name);
    println!("{}", user1.password);

    let mut user2 = User {
        name: String::from("siyehua"),
        ..user1 // è¢«å¤åˆ¶çš„å¯¹è±¡å¿…é¡»å¸è½½æœ€åé¢
    };
    println!("{}", user1.name);
    // println!("{}", user1.password);// æŠ¥é”™ï¼Œå› ä¸º password çš„å€¼å·²ç»å€Ÿç»™ user2 äº†

}

struct User {// å®šä¹‰äº†å››ä¸ªå­—æ®µ
    id: u32,
    name: String,
    password: String,
    email_address: String,
}
```

ä¹Ÿå¯ä»¥å®šä¹‰ tuple structs å…ƒç»„ç»“æ„ä½“, å…ƒç»„ç»“æ„ä½“ä¸æ™®é€šç»“æ„çš„åŒºåˆ«æ˜¯ï¼Œå®ƒä¸éœ€è¦ç»™å‡ºå­—æ®µå‘½åã€‚<br>
æ³¨æ„ï¼Œç›¸åŒç»“æ„çš„å…ƒç»„ä¸èƒ½ç›¸äº’å¤åˆ¶ï¼Œå°½ç®¡ä»–ä»¬çš„å­—æ®µæ˜¯ä¸€æ ·çš„ï¼Œè¿™ç‚¹å’Œ ts/js æ˜¯ä¸åŒçš„

```rust
fn main(){
    let tuple1 = MyTuple1(10, 20.0, String::from("123234"));
    let tuple2 = MyTuple2(10, String::from("123234"), 20.0);
    println!("{}", tuple1.0);
}

struct MyTuple1(i32, f32, String);

struct MyTuple2(i32, String, f32);
```


### å•å…ƒç»“æ„ä½“ Unit-like Struct 

å•å…ƒç»“æ„ä½“å°±æ˜¯ä¸€ä¸ªæ ‡è®°ï¼Œå®ƒçš„ä½œç”¨ç±»ä¼¼äºä¸€ä¸ªæ²¡æœ‰ä»»ä½•æ–¹æ³•çš„æ¥å£ï¼Œè¿™æ ·æˆ‘ä»¬å¯ä»¥å°†å®ç°ä¸åŒçš„å•å…ƒç»“æ„çš„å¯¹è±¡æ”¾åœ¨åŒä¸€ä¸ªæ•°ç»„é‡Œï¼Œè¿™æ ·æˆ‘ä¼°è®¡æ˜¯ä¸ºäº†æ›´å¥½çš„
æ”¯æŒæ³›å‹ç­‰ç±»å‹ï¼Œåé¢æˆ‘ä»¬ä¼šå­¦åˆ°ï¼Œè¿™é‡Œæˆ‘ä»¬åªéœ€è¦è®°ä½ï¼š

`å•å…ƒç»“æ„ä½“å°±æ˜¯æ²¡æœ‰ä»»ä½•å­—æ®µçš„ç»“æ„ä½“`

```rust
struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
}
```

æ‰“å°ç»“æ„ä½“ï¼Œé»˜è®¤ç»“æ„ä½“æ˜¯ä¸èƒ½æ‰“å°çš„ï¼Œå¯ä»¥è¿™ä¹ˆä¿®æ”¹ï¼š

```rust
fn main(){
    let mylocation = MyLocation {
        x: 10,
        y: 20,
        name: String::from("William"),
    };
    println!("{:#?}", mylocation);
    println!("{:?}", mylocation);
    dbg!(&mylocation);
}

#[derive(Debug)] // è¿™é‡Œå¿…é¡»æ ‡è®°æ‰èƒ½æ‰“å°
struct MyLocation {
    x: i32,
    y: i32,
    name: String,
}
```

## å‡½æ•°ä¸æ–¹æ³•

æ–¹æ³•ï¼šå†™åœ¨ç»“æ„ä½“ï¼Œæšä¸¾æˆ– trait ä¸­ï¼Œç¬¬ä¸€ä¸ªå‚æ•°å¿…é¡»æ˜¯å¯¹è±¡æœ¬èº«ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæ–¹æ³•ä¸€å®šæ˜¯æŸä¸ªå®ä¾‹çš„æ–¹æ³•<br>ï¼Œ ä½¿ç”¨ `obj.function_name()` è°ƒç”¨<br>
å‡½æ•°ï¼šä¸éœ€è¦å¯¹è±¡å°±å¯ä»¥è°ƒç”¨ï¼Œä½¿ç”¨ `MyClass::function_name()` è°ƒç”¨<br>

ä»¥ä¸Šé¢çš„ä¾‹å­ä¸ºä¾‹ï¼Œç»™å®ƒå†™ä¸€ä¸ªæ–¹æ³•

```rust
fn main(){
    let mylocation = MyLocation {
        x: 10,
        y: 20,
        name: String::from("William"),
    };
    println!("{:#?}", mylocation);
    println!("{:?}", mylocation);
    dbg!(&mylocation);
    
    mylocation.show_location();
    let mylocation = MyLocation::create_same(40);
    print!("x {} y {}", mylocation.x, mylocation.y);
}

impl MyLocation {
    fn show_location(&self) { // æ–¹æ³•
        println!("x: {}, y: {}", self.x, self.y);
    }

    fn create_same(size: i32) -> Self { // å‡½æ•°
        return Self {
            x: size,
            y: size,
            name: String::from("same size"),
        };
    }
}
```

## æšä¸¾ Enum

ä½¿ç”¨æšä¸¾æ›´åŠ æ–¹ä¾¿ï¼Œå¯ä»¥å¤šå¤šä¸ªä¸åŒçš„ç»“æ„ä½“å…³è”èµ·æ¥ï¼Œä¾‹å¦‚, æ€§åˆ«æœ‰ç”·ï¼Œå¥³ï¼Œä½¿ç”¨ struct æ˜¯è¿™ä¹ˆå®šä¹‰çš„ï¼›

```rust
fn main(){
    let a = Woman {
        name: String::from("Lisa"),
    };
    let b = Man {
        name: String::from("Ben"),
    };
}

struct Woman {
    name: String,
}

struct Man {
    name: String,
}
```

è¿™ä¸ªæ—¶å€™ï¼Œä¸ºäº†ç»Ÿä¸€ name å±æ€§ï¼Œéœ€è¦ä½¿ç”¨ `traits` æ¥ç»Ÿä¸€ï¼Œå¾ˆéº»çƒ¦ï¼Œä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œå¯ä»¥ä½¿ç”¨æšä¸¾ï¼š

```rust
fn main(){
    let a = Person::MAN(String::from("Ben"));
    let b = Person::WOMAN(String::from("Lisa"));
}

enum Person {
    MAN(String),
    WOMAN(String),
}
```

å¦å¤–ï¼Œæšä¸¾æ”¯æŒæ¯ä¸€ä¸ªæšä¸¾å€¼éƒ½å¯ä»¥ä½¿ç”¨ä¸åŒçš„å‚æ•°ï¼š

```rust
enum MyEnum {
    TYPE1(i32),
    TYPE2(String),
    TYPE3,
}
```

## ç®¡ç† project
package, crate, module ä¹‹å‰çš„å…³ç³»:<br>
package = project, package é‡Œé¢å¯ä»¥æœ‰å¤šä¸ª crate<br>
crate = library, åŒ…æ‹¬ binary crate :main.rs, lib crate: lib.rs, ä»¥åŠæ¯ä¸ªç›®å½•ä¸‹å•ç‹¬çš„ lib crate<br>
module åŒ…å«åœ¨ crate ä¸­ï¼Œä½¿ç”¨ mod æ¥å®šä¹‰, module å°±æ˜¯æŸä¸ªåŠŸèƒ½æ¨¡å—

```
foobar //æ•´ä¸€ä¸ªå« package
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ build.rs
â””â”€â”€ src/
    â”œâ”€â”€ main.rs // binary crate
    â”œâ”€â”€ util.rs
    â”œâ”€â”€ lib.rs // lib crate
    â””â”€â”€ bin/
        â””â”€â”€ alt.rs // binary crate
```


### module

ä¸Šé¢çš„ç›®å½•ç»“æ„å±•ç¤ºäº† package å’Œ crate ï¼Œä½†æ˜¯æ²¡æœ‰åŒ…å« moduleï¼Œmodule é€šå¸¸åœ¨ crateä¸­ï¼Œä»¥ä¸‹æ˜¯ä¸€ä¸ªå®šä¹‰åœ¨ main.rs ä¸­çš„ä¾‹å­ï¼š

```rust
pub mod custom_mod {
    // è¿™é‡Œå®šä¹‰äº†ä¸€ä¸ª module
}
fn main(){
    
}
```

cargo ä¼šç”¨ä¸‹é¢ä¸‰ç§æ–¹æ³•æŸ¥æ‰¾ï¼š
1. é¦–å…ˆåœ¨ mod custom_mod åæ¥çœ‹çœ‹æœ‰æ²¡æœ‰ç‚¹å¤§æ‹¬å·åŒ…è£¹çš„ module
2. æ²¡æœ‰ï¼Œå°±åœ¨ main.rs ä¸­æŸ¥æ‰¾ src/custom_mod.rs æ–‡ä»¶
3. å¦‚æœè¿˜æ˜¯æ²¡æœ‰ï¼Œå°±åœ¨ src/custom_mod/mod.rs ä¸­æ‰¾

``` 
// è¿™é‡Œå±•ç¤ºç¬¬ä¸‰ç§æ–¹å¼
backyard
â”œâ”€â”€ Cargo.lock
â”œâ”€â”€ Cargo.toml
â””â”€â”€ src
    â”œâ”€â”€ custom_mod
    â”‚Â Â  â””â”€â”€ mod.rs
    â””â”€â”€ main.rs
```

```rust
use crate::custom_mod::MyView; // ä½¿ç”¨ custom_mod module ä¸­çš„æŸä¸ªç»“æ„ä½“

pub mod custom_mod;
fn main(){
    custom_mod::eat_at_restaurant(); // è°ƒç”¨ eat_at_restaurant å‡½æ•°
}
```

```rust
// src/custom_mod/mod.rs ä¸­çš„å†…å®¹
pub struct MyView {
}

mod front_of_house { // è¿™é‡Œå®šä¹‰ä¸€ä¸ªæ–°çš„ module,  front_of_house å¯æ˜¯ä¸å…¬å¼€
    pub mod hosting { // å­ module å¿…é¡»æ˜¯å…¬å¼€çš„ï¼Œä¸ç„¶ eat_at_restaurant è®¿é—®ä¸äº†
        pub fn add_to_waitlist() { // add_to_waitlist å‡½æ•°å¿…é¡»æ˜¯å…¬å¼€çš„ï¼Œä¸ç„¶ eat_at_restaurant è®¿é—®ä¸äº†
            println!("add_to_waitlist");
            aaa();
        }
        fn aaa(){
            super::super::ttt(); // å¯ä»¥è°ƒç”¨çˆ¶ module ï¼Œçˆ¶ module çš„å‡½æ•°ä¸éœ€è¦å£°æ˜æˆ pub çš„
        }
    }
}

pub fn eat_at_restaurant() { // æä¾›ä¸€ä¸ªå‡½æ•°ç»™å¤–éƒ¨è°ƒç”¨
    // Absolute path
    crate::custom_mod::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
```

struct çš„å±æ€§é»˜è®¤æ˜¯ç§æœ‰çš„ï¼Œenum çš„å±æ€§é»˜è®¤æ˜¯å…¬å¼€çš„

```rust
mod back_of_house {
    pub struct Breakfast { // æŠŠé‡Œé¢çš„ç»“æ„ä½“æ”¹æˆ pub çš„
        pub toast: String, // æŸä¸ªå­—æ®µè®¾ç½®æˆ pubï¼Œåˆ™å¤–éƒ¨å°±å¯ä»¥è®¿é—®
        seasonal_fruit: String,
    }

    impl Breakfast {
        pub fn summer(toast: &str) -> Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from("peaches"),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    // Order a breakfast in the summer with Rye toast
    let mut meal = back_of_house::Breakfast::summer("Rye");
    // Change our mind about what bread we'd like
    meal.toast = String::from("Wheat");
    println!("I'd like {} toast please", meal.toast);

    // The next line won't compile if we uncomment it; we're not allowed
    // to see or modify the seasonal fruit that comes with the meal
    // meal.seasonal_fruit = String::from("blueberries");
}
```


```rust
mod front_of_house2 {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house2::hosting; // ç»™ use è¯­å¥åŠ ä¸Š pubï¼Œè¿™æ ·ç›¸å½“äºç»™ hosting è¿™ä¸ªå­ module æå–åˆ°äº†å¤–éƒ¨

fn main() {
    hosting::add_to_waitlist();
}
```

## é›†åˆ collections
é›†åˆåŒ…æ‹¬ vector, map å’Œ string (String æ˜¯ char çš„é›†åˆ)

### vector

```rust
fn main(){
    // ç®€å•çš„ä½¿ç”¨
    let v: Vec<i32> = Vec::new();
    let mut v = vec![1, 2, 3];
    // let v = vec![1, 2.0, 3]; // ç¼–è¯‘ä¼šæŠ¥é”™ï¼Œ2 æ˜¯ float ç±»å‹ï¼Œä¸èƒ½ä¸ i32 æ··è£…
    // v.push(2.0);// æŠ¥é”™ï¼Œ2.0 ä¸æ˜¯ i32 ä¸ºï¼Œä¸å¯æ·»åŠ 
    v.push(100);
    v.push(1);

    let value = &v[2]; // ä½¿ç”¨ index ä¸‹æ ‡è¿›è¡Œè¯»å–
    println!("value:{value}");
    let value: Option<&i32> = v.get(2); // ä½¿ç”¨ get æ–¹æ³•è¯»å–
    match value {
        Some(value) => println!("The third element is {value}"),
        None => println!("There is no third element."),
    }

    // let value = &v[20]; // æŠ¥é”™ï¼Œè¶…å‡ºäº† index ä¸‹æ ‡
    // println!("value:{value}");
}
```


```rust
fn main(){
    let mut v = vec![1,3,4,6];
    let mut v1 = &v[2]; // ä¸å¯å˜çš„
    v.push(3); // å¯å˜çš„
    // æŠ¥é”™ï¼Œä¸€ä¸ª scope ä¸­ï¼Œä¸èƒ½åŒæ—¶å­˜åœ¨ä¸å¯å˜çš„å¼•ç”¨å’Œå¯å˜çš„å¼•ç”¨
    // å› ä¸º vector çš„å†…å­˜æ˜¯è¿ç»­çš„ï¼Œæ·»åŠ ä¸€ä¸ªæ–°çš„å…ƒç´ (push), å¯èƒ½å¯¼è‡´é‡æ–°åˆ†é…å†…å­˜ï¼Œè¿™ä¸¤å¯¼è‡´ä¹‹å‰çš„ v1 æŒ‡å‘çš„å†…å­˜å¤±æ•ˆ
    // print!("v1 value:{}", v1); 
}
```

### String

string æ˜¯ä¸€ç§ç‰¹æ®Šçš„é›†åˆï¼Œå®ƒä¸å¯ä»¥ä½¿ç”¨ `str[index]` ä¸‹æ ‡æ¥è®¿é—®ï¼Œå› ä¸ºå®ƒå§‹ç»ˆæ˜¯ä»¥ UTF-8 çš„å½¢å¼è¿›è¡Œå­˜å‚¨çš„ï¼Œæ‰€ä»¥ä½¿ç”¨ä¸‹æ ‡è¿›è¡Œè®¿é—®ï¼Œ
å¯èƒ½ä¸åŒçš„è¯­è¨€ã€ç¼–ç ï¼Œè¿”å›çš„ç»“æœæ˜¯ä¸ä¸€æ ·çš„ã€‚å°½ç®¡å¯æ˜¯ç›´æ¥è¿”å› byte å­—èŠ‚ï¼Œä½†æ˜¯ byte å­—èŠ‚å¯¹ä½¿ç”¨è€…å¾ˆä¸ç›´æ¥ï¼Œæ— æ³•å‡†ç¡®çŸ¥é“å®ƒæ˜¯ä»£è¡¨ä»€ä¹ˆå†…å®¹

```rust
//string çš„ç®€å•ä½¿ç”¨
fn main(){
    let t = "fefef";
    let mut a = String::new();
    a.push_str(t);
    a.push('f');
    let a = String::from(t);

    let s1 = String::from("Hello, ");
    let s2 = String::from("world!");
    let s3 = s1 + &s2; // note s1 has been moved here and can no longer be used
    println!("s3:{}", &s3);


    let s1 = String::from("Hello, ");
    let s2 = String::from("world!");
    // let s3 = &s1 + &s2; // æ— æ³•ç¼–è¯‘ï¼Œ&String æ²¡æœ‰é‡å†™ + ç¬¦å·
    // println!("s3:{}", &s3);

    let s1 = String::from("Hello, ");
    let s2 = String::from("world!");
    let s3 = s1 + "-" + &s2;
    println!("s3:{}", &s3);
}
```

### map

map çš„æ“ä½œä¸ vector åŸºæœ¬æ˜¯ä¸€ç›´çš„ï¼Œä½†æ˜¯ map åœ¨é›†åˆä¸­æ²¡æœ‰ String å’Œ vector å¸¸è§ï¼Œæ‰€ä»¥éœ€è¦æˆ‘ä»¬å¯¼åŒ…

```rust
fn main(){
    let mut v = HashMap::new();
    v.insert("123", 4);
    v.insert("567", 4);
    v.remove("567");
    println!("{}", v.get("123").unwrap());
    // println!("{}", v.get("456").unwrap()); // æŠ¥é”™ï¼Œ567 å·²ç»è¢«ç§»é™¤
    println!("{}", v.get("456").copied().unwrap_or(100)); // è¾“å‡º 100

    for (key, value) in v {
        println!("key:{}, value:{}", key, value);
    }


    let field_name = String::from("Favorite color");
    let field_value = String::from("Blue");
    let mut map = HashMap::new();
    // map.insert(field_name, field_value);// ç›´æ¥ç©¿ field_name ä¼šå¯¼è‡´ field_name åé¢æ‰“å°é”™è¯¯
    map.insert(&field_name, &field_value);
    // field_name and field_value are invalid at this point, try using them and
    // see what compiler error you get!
    println!("name:{}, value:{}", field_name, field_value);
}
```

## é”™è¯¯å¤„ç†

rust çš„é”™è¯¯åˆ†æˆä¸¤ç§ï¼šå¯æ¢å¤çš„(Result) å’Œä¸å¯æ¢å¤çš„ (panic)

```rust
fn main(){
    // let file = File::open("hello.txt");
    // let file = match file {
    //     Ok(f) => f,
    //     Err(e) => panic!("open fail:{}", e.kind()), // æŠ¥é”™æ‰¾ä¸åˆ°æ–‡ä»¶
    // };
    // println!("open file success!");

    let file = File::open("hello.txt");
    if file.is_err() {
        if file.err().unwrap().kind() == ErrorKind::NotFound { // åˆ¤æ–­é”™è¯¯ç±»å‹
            println!("Can't found the file,so create it!");
            File::create("hello.txt").expect("create error");
        } else {
            panic!("open fail:{}", e)
        }
    }
}
```

```rust
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let username_file_result = File::open("hello.txt");

    let mut username_file = match username_file_result {
        Ok(file) => file,
        Err(e) => return Err(e),
    };

    let mut username = String::new();

    match username_file.read_to_string(&mut username) {
        Ok(_) => Ok(username),
        Err(e) => Err(e),
    }
}


// ä½¿ç”¨ï¼Ÿ ç®€åŒ–
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let mut username_file = File::open("hello.txt")?;
    let mut username = String::new();
    username_file.read_to_string(&mut username)?;
    Ok(username)
}

// æˆ–è€…è¿™æ ·ç®€åŒ–
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let mut username = String::new();
    File::open("hello.txt")?.read_to_string(&mut username)?;
    Ok(username)
}

// æ›´ç®€å•çš„
use std::fs;
use std::io;

fn read_username_from_file() -> Result<String, io::Error> {
    fs::read_to_string("hello.txt")
}


// ä½¿ç”¨ option
fn last_char_of_first_line(text: &str) -> Option<char> {
    text.lines().next()?.chars().last()
}

// ä¸è¿”å›ä»»ä½•ä¸œè¥¿
use std::error::Error;
use std::fs::File;

fn main() -> Result<(), Box<dyn Error>> {
    let greeting_file = File::open("hello.txt")?;
    Ok(())
}

```

## æ³›å‹ï¼Œç‰¹å¾å’Œç”Ÿå‘½å‘¨æœŸ Generic Types, Traits, and Lifetimes

### æ³›å‹

æ³›å‹è·Ÿå…¶ä»–çš„è¯­è¨€æ²¡æœ‰ä»€ä¹ˆä¸ä¸€æ ·ï¼Œå¹¶ä¸”å®ƒåœ¨è¿è¡Œæ—¶çš„æ¶ˆè€—å’Œæ™®é€šç±»å‹æ˜¯ä¸€æ ·çš„ã€‚

```rust
fn main(){
    let v = MyType {
        x: 10,
        y: 10,
    };
    let a = v.f();
    let b = v.f2();
    println!("{}, {}", &a, &b);
    let a = "my";
    let c = return_it(&a);
    println!("{}", &c);
}


// æ³›å‹ç±»
struct MyType<T> {
    x: T,
    y: T,
}

// æ³›å‹æ–¹æ³•
impl<T> MyType<T> {
    fn f(&self) -> &T {
        &self.x
    }
}

// æŒ‡å®šæ³›å‹çš„çš„ç±»å‹
impl MyType<i32> {
    fn f2(&self) -> &i32 {
        &self.y
    }
}

// æ™®é€šçš„æ³›å‹æ–¹æ³•
fn return_it<T>(v: &T) -> &T {
    &v
}
```

### ç‰¹å¾ trait

trait ç±»ä¼¼äºæ¥å£ï¼ŒåŠŸèƒ½åŸºæœ¬ä¸Šæ˜¯ä¸€æ ·çš„

```rust
fn main(){

    let t = Teacher { name: "Lisa".to_string() };
    let c = Student { name: "Duo".to_string() };
    t.print_name();
    c.print_name();

    print_obj("have a try");
    print_obj(10);
    print_multiple(t);
    // print_multiple(c); // æŠ¥é”™ï¼Œstudent æ²¡æœ‰å®ç° Displayï¼Œæ‰€ä»¥æ— æ³•æ‰“å°
}

struct Teacher {
    name: String,
}

struct Student {
    name: String,
}

trait Human {
    // æ²¡æœ‰å®ç°
    fn get_name(&self) -> String;
    // æœ‰é»˜è®¤å®ç°
    fn print_name(&self) {
        println!("Your name is:{}", self.get_name())
    }
}

impl Human for Teacher {
    fn get_name(&self) -> String {
        format!("{}", self.name)
    }
}

impl Display for Teacher {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        Display::fmt(self.name.as_str(), f)
    }
}

impl Human for Student {
    fn get_name(&self) -> String {
        format!("{}", self.name)
    }

    fn print_name(&self) {
        println!("I a student, my name is:{}", self.get_name())
    }
}

// é™å®š
fn print_obj<T: Display>(value: T) {
    println!("{}", value);
}

// å¤šç§ç»„åˆ
fn print_multiple2<T: Display + Human>(value: T) {
    println!("{}", value);
}

// å¦å¤–ä¸€ç§å†™æ³•
fn print_multiple<T>(value: T) where T: Display + Human, {
    println!("{}", value);
}

// æ— æ³•ç¼–è¯‘ï¼Œrust ä¸­ä¸å…è®¸è¿”å›å¤šä¸ªä¸åŒçš„ç±»å‹
// fn get_human(value: bool) -> impl Human {
//     if value {
//         Teacher { name: "Lisa Teacher".to_string() }
//     } else {
//         Student { name: "Student".to_string() }
//     }
// }
```

### ç”Ÿå‘½å‘¨æœŸ

```rust
// å¯ä»¥ä¸å£°æ˜ç”Ÿå‘½å‘¨æœŸï¼Œä¼šè‡ªåŠ¨æ¨æ–­
fn longest3(x: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

// æœ‰ä¸¤ä¸ªè¾“å…¥ï¼Œæ— æ³•è‡ªåŠ¨æ¨æ–­
fn longest2<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

// fn longest(x: &str, y: &str) -> &str {
//     if x.len() > y.len() {
//         x
//     } else {
//         y
//     }
// }

use std::fmt::Display;

fn longest_with_an_announcement<'a, T>(
    x: &'a str,
    y: &'a str,
    ann: T,
) -> &'a str
    where
        T: Display,
{
    println!("Announcement! {}", ann);
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

## æµ‹è¯• test

```
$ cargo tset // æµ‹è¯•æ‰€æœ‰çš„æ–¹æ³•
$ cargo test æ–¹æ³•å // ä»…æµ‹è¯•æŒ‡å®šçš„æ–¹æ³•
$ cargo test pre_xxx // å¦‚æœåªè¾“å…¥éƒ¨åˆ†æ–¹æ³•åå­—ï¼Œåˆ™ä¼šè‡ªåŠ¨åŒ¹é…æ‰€æœ‰ç¬¦åˆçš„æ–¹æ³•å¹¶è¿›è¡Œæµ‹è¯•
#[ignore] æ–¹æ³•æ·»åŠ è¿™ä¸ªæ ‡è®°
$ cargo test --ignored // æµ‹è¯•ä½¿ç”¨ ignored å¯ä»¥å¿½ç•¥è¿™ä¸ªæ–¹æ³•æµ‹è¯•
$ cargo test --show-output // è¡¨ç¤ºè¦è¾“å‡º println çš„æ‰“å°
$ cargo test --test-threads=1 // è¡¨ç¤ºåªç”¨ä¸€ä¸ªçº¿ç¨‹è¿›è¡Œæµ‹è¯•ï¼Œä¸å¹¶è¡Œæµ‹è¯•
```

## å‘½ä»¤è¡Œ

å‘½ä»¤è¡Œæ˜¯ä¸€ä¸ªå•ç‹¬çš„é¡¹ç›®ï¼Œ[è¯¦è§](https://github.com/siyehua/mingrep)

```rust
fn main() {
    // cargo run -- siyehua testfile.txt > output.txt
    // -- å¯é€‰å‚æ•°
    // > è¾“å…¥åˆ°æŒ‡å®šçš„æ–‡ä»¶
    // env::args() è·å–å‘½ä»¤è¡Œè¾“å…¥çš„å‚æ•°
    let inputs: Vec<String> = env::args().collect();
    let config = Config::build(&inputs).unwrap_or_else(|err| {
        // ä½¿ç”¨ eprintln æ›¿æ¢ println, å°±ä¸ä¼šè¾“å‡ºåˆ°æ–‡ä»¶ä¸­
        eprintln!("Problem parsing arguments: {err}");
        process::exit(1);
    });

    run(&config).unwrap_or_else(|err|{
        eprintln!("Read file '{}' content error: {err}", &config.file_path);
        process::exit(1);
    });
}
```

å…¶ä¸­é¡¹ç›®ä¸­çš„ lib.rs ä¸ main.rs åŒçº§ï¼Œä½¿ç”¨çš„æ—¶å€™å¯ä»¥ç›´æ¥é€šè¿‡ project::mod å¯¼å…¥ï¼Œä¾‹å¦‚ï¼š

```rust
use mingrep::{Config, run};

// è¯»å–ç¯å¢ƒå˜é‡ env::var(ç¯å¢ƒå˜é‡ key)
let ignore_case = env::var("IGNORE_CASE").is_ok();
```

