# Rust 学习笔记

## 编译配置

### rust 命令

```shell
# 查看当前的 rust 版本
rustc --version
# 升级 rust 
rustc update
# 编译一个 rust 文件
rustc main.rs
# 查看 文档
rustup doc
```

### cargo 命令

```shell
# 创建一个项目, hello-rust 是项目名称，项目名称遵循 xxx-xxx 原则，字母都用小写字母 
carg new hello-rust --vcs=git
# 编译一个项目, 编译之后会生成一个 debug 的目录，进入该目录之后就可以运行
# 如果需要编译 release 的，可以使用 -help 查看帮助，默认编译的是 debug
cargo build
# 运行一个项目
cargo run 
# 运行时检查一个项目情况
# check 命令要比 run 快，因为它不需要运行，如果项目非常大，需要编译很久才能运行，而稍微有点错误
# 就会导致运行失败，使用 run 命令就会让人抓狂，check 命令就能改善这种情况
cargo check 
```

## 项目结构

下面展示了一个简单的项目结构：<br>

```
.
├── Cargo.lock // 当前项目与第三方的版本配置，通常这个也会加入到 git 版本控制中，因为有的项目可能需要特定的版本才能编译
├── Cargo.toml // 当前项目与第三方的版本配置, 与 lock 不同，这里是配置的地方
├── readme.md // 项目说明
├── src // 项目源码存放位置
│   └── main.rs // 项目源代码
└── target // 编译后的目录存放位置，通常该文件不会加入到 git 版本控制中
    ├── CACHEDIR.TAG 
    └── debug // 上面提到的 cargo build 后的产物就存在当前目录下
        ├── build
        ├── deps
        ├── examples
        └── incremental
```

### Cargo.toml 配置文件详解

```toml
[package]
name = "hello_cargo" # 当前项目名称
version = "0.1.0" # 当前项目版本
edition = "2021" # 修改时间

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
rand = "0.8.5" # 表示用了一个 rand 第三方库，版本是 0.8.5
# 添加完之后，使用 cargo build 就可以把该第三方的以及它关联的第三方都拉下来，并存储到 .lock 文件中

# 使用非固定版本
#rand = "^0.8.5" # 表示用最新的0.8.x 版本，该版本始终小于 0.9.0 
#前面说了 .lock 文件会将第三方版本版本锁定在某个版本，例如 0.8.6， 过了一段时间后，该第三方库的作者
#发布了 0.8.7， 项目不会自动更新到该版本，尽管使用了 ^, 要想主动更新，可是使用：cargo update 来更新
#注意，如果有更新，会同步想改 .lock 文件锁定的版本
```

### Cargo.lock 版本详解

该文件不需要手动编辑，会自动根据环境生成，

```toml
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 3

[[package]]
name = "hello_cargo" # 项目名称
version = "0.1.0" # 项目版本
dependencies = [ # 当前项目依赖的第三方
 "rand",
]

[[package]]
name = "rand" # 依赖的第三方
version = "0.8.5" # 版本
source = "registry+https://github.com/rust-lang/crates.io-index" # 源码地址
checksum = "34af8d1a0e25924bc5b7c43c079c942339d8f0a8b57c39049bef581b46327404"
dependencies = [ # 该第三方又依赖了其他的第三方
    "libc",
    "rand_chacha",
    "rand_core",
]
#... 还有很多 ...
```

## 编码前提

这里说一下编码的基础情况

```rust
// 使用  use 导入某个包， :: 两个冒号来表示引用某个类
use std::io;
fn main(){ // fn 表示函数， main() 表示项目的入口
    let guess = "123";
    println!("You guessed: {guess}"); // println! 输出, {} 来引入变量
    println!("You guessed: {}", guess); // 也可以这么写

    io::stdin() // 输入
        .read_line(&mut guess)
        .expect("Failed to read line"); // 错误捕捉

    let guess: u32 = match guess.trim().parse() { // 错误捕捉 返回一个 Ok 与 Err, Ok 里面有正确的值
        Ok(num) => num, 
        Err(_) => println!("error"),
    };
}
```

## 变量与类型

rust 类型编译的时候就已经确定

```rust
let x = 5; // 编译定义了一个变量 x 的类型是 i32， 主要该变量 x 是不可以修改的

x = 10; // 这一行代码会报错，应该默认的 x 是不可以修改的

let mut y = 10; // 使用 mut 来表示 y 是可变的
y = 20; // 可以正确的编译

let mut y = "I am string!"; // 类型覆盖，可以将 y 的类型修改改成 String, 这是运允许的
y = 20; // 报错！ 修改之后 y 就是 String 类型，此时再赋值成 i32 类型就会报错
y = "new String"; // 正确

// 常量， 注意常量不可以被覆盖
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
// let mut THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3; // 报错
// println!("new {THREE_HOURS_IN_SECONDS}");
//   |
// 8 |     const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
//   |     ------------------------------------------------ the constant `THREE_HOURS_IN_SECONDS` is defined here
// 9 |     let mut THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
//   |             ^^^^^^^^^^^^^^^^^^^^^^ cannot be named the same as a constant
```

### 整型

i 表示有符号，范围是：-(2n - 1) to 2n - 1 - 1  u 表示无符号， 范围是：0 to 2n - 1 - 1

|Length	|Signed	|Unsigned|
| --- | --- | --- |
|8-bit	|i8	|u8|
|16-bit	|i16	|u16|
|32-bit	|i32	|u32|
|64-bit	|i64	|u64|
|128-bit	|i128	|u128|
|arch	|isize	|usize|

### 浮点型

浮点型比较简单，只有两种类型，分别是 f32 和 f64, 默认类型是 f64, 因为市面上大多数的机器64 位能有 32 位的运行性能

### 计算

计算支持基本的加减乘除与取余操作，但是不支持两个不同类型的直接计算，例如：

```rust
let a = 10;
let b = 20.0;
let c = a * b; // 报错
//   |
//   |     let c = a * b;
//   |               ^ no implementation for `{integer} * {float}`
//   |
//   = help: the trait `Mul<{float}>` is not implemented for `{integer}`
```

### 布尔类型

```rust
let a = true;
let b: bool = false;
```

### char 类型

只允许设置单个字符，它占用 4 个字节，允许使用 ASCII 码，中文，日语，韩语，emoji, zero-width spaces 等等。
一个字符不等于一个 Unicode

```rust
let c = '2';
let d: char = '王';
let e = '😄';
```

### 元组

元组的长度是固定不变的，不可以修改，例如：

```rust
    let t : (f32, f64, u32) = (500.0, 6.4, 1); // 三个元组
let t1 = t.0; // 通过数字下标来访问元组
let t2 = t.1;
let t3 = t.2;

println!("t: {t1}");
println!("t: {}", t.2);

let t : (f32, f64, u32, u64) = (500.0, 6.4, 1, 64); // 四个元组
let t1 = t.0;
let t2 = t.1;
let t3: u32 = t.2;
let t3: u64 = t.3;

let t2 : (f32) = (500.0); // 一个也能组成元组

let t3 = (500.0, 6.4, 1, 64); // 不写类型 的话会自动使用默认的基本类型
```


### 数组

数组与元组不同的是，数组里面的元素必须是同一个类型，例如：

```rust
let a: [i32; 4] = [1, 2, 3, 4]; // 表示一个 int 32 位，长度是 4 的数组
let a = [1, 2, 3, 4]; // 简写：表示一个 int 32 位，长度是 4 的数组
let a = [4; 5]; // 简写 [value; length] ：表示一个 int 32 位，长度是 5， 并且每一个数字都是 4
let size = a.len();
println!("{}, {size}", a[0]); // 通过下标访问某个元素
```


## 函数


```rust
fn main() {
    another_function();
}

fn another_function() {
    // 另外一个函数，函数命名遵循使用下划线命名方法
    println!("Call another function!!")
}


// 传参数
fn main() {
let a = 10;
let b = 30.0;
print_params(a, b);
}

fn print_params(x: i32, y: f64){
    println!("x {x} y:{y}");
}
```

### 返回值

函数如果有返回值，必须使用 -> 类型来声明，例如 -> i32, 返回时，通常使用最后一个值作为返回值，
也可是使用 return 来提前返回

```rust

fn five() -> i32 {
    5
}

fn main() {
    let x = five();
    println!("The value of x is: {x}");
}

fn test_return() {
    return 10; // 报错，函数没有声明返回，函数的返回值不能直接推导出来
}

fn test_return() -> i32 {
    10; // 报错，rust 是表达式语言，最后一个值不能加上；分号
}
```

### 语句与表达式

Rust 是以表达式为基础的，语句会返回值，但是表达式不会，举例子:

```rust
// 区别 1
let a = b = 5; // 报错，在语句中可以，但是在表达式中， b = 5 不会返回任何值

// 区别 2
let mut a = 10;
let b = { // 注意此时 b 没有任何类型
    a = 100;
    a + 10; // 末尾加上了分号，则没有返回任何数据
};
let b = {
    a = 100;
    a + 10 // 没有加分号，则这个值就是 b 的值
};
println!("{b}");
```

## 控制流

条件语句 if, 注意 在条件判断中， else if 与  else 都是可选的

```rust
let a = 10;
if a == 10 { // if
    println!("true");
} else if a > 10 { // else if
    println!("20")
} else { // else
    println!("30")
}
let b = if a == 10 { 2 } else { 30 };
```

#### 循环

循环有 loop, for 和 while, loop 类似于 do .. while:

```rust
loop { // 类似于 do .. while
    println!("100");
    break;
}


let a  = loop { // 类似于 do .. while
    println!("100");
    break 10; // 意思是返回最后返回一个 10
};
```


给 loop 添加 label,使用 continue 或 break 的时候，能指定它：

```rust
fn main() {
    let mut count = 0;
    'counting_up: loop { // 给外层的 loop 增加了一个标记 label
        println!("count = {count}");
        let mut remaining = 10;

        loop {
            println!("remaining = {remaining}");
            if remaining == 9 {
                break; // 这里打断的是最近的那个循环，最接近当前语句是得里面的 loop
            }
            if count == 2 {
                break 'counting_up; // 打断指定的 loop
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("End count = {count}");
}
```

#### while
```rust
fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index < 5 {
        println!("the value is: {}", a[index]);

        index += 1;
    }
}
```

#### for
```rust
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("the value is: {element}");
    }
}
fn main() {
    for number in (1..4).rev() {
        println!("{number}!");
    }
    println!("LIFTOFF!!!");
}
```

## Ownership: 所有权

### stack 与 heap

stack 符合后进先出的原则，类似于跌盘子，放到这里的数据必须是固定的长度<br>
heap 需要先找到一块合适的内存空间，然后在申请指定的大小<br>


下面例子中，字面量 &str 就是分配在 stack 中，它的大小是可以预知的， String 就是分配在 heap 中的,
因为它可以随时修改

```rust
// 字面量：字面量是不可以修改的
let mut a = "1234"; // &str  字面量
let b = a;
a = "456";
println!("{}, {}", a, b); // 输出 456， 1234

// String 与字面量不同，String 是可以修改的
let mut a = String::from("1234"); // String
a.push_str(" 567");
println!("{}",a); // 输出 1234 567， String 是可以修改的
```

所有的基本类型与字面量， 仅包含基本类型的元组都会被放到 stack 上，因为它们的大小是确定的，其他的类型
则会放到 heap 堆中。

### 所有权规则
1. 每个值都有且仅有一个 owner
2. 在同一个时间也仅能有一个 owner
3. 当 owner 超出范围，对应的值就会被删除 drop

举个例子：

```rust
let s1 = String::from("hello");
let s2 = s1; // 根据规则 1，此时 hello 已经把 hello 所有权从 s1 交给了 s2

// 打印 s1 时， 会报错，因为此时 s1 已经把值借给 s2 了
println!("{}, world!", s1);

```

解决方法，根据报错：

```
   |
88 |     let s1 = String::from("abc"); // 如果s1 的类型是基本类型，或者实现了  `Copy` trait , 则实现的是拷贝值，而不是地址
   |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
89 |     let s2 = s1;
   |              -- value moved here // 值被移动了
90 |     println!("{}", s1);
   |                    ^^ value borrowed here after move // 值被借走了，所以 s1 此时没有值，无法打印
   |
   = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider cloning the value if the performance cost is acceptable
   |
89 |     let s2 = s1.clone(); // 解决办法，可以使用拷贝方法，明确告诉编译器，s2 要拷贝值
   |                ++++++++

```

前面说了，基本类型，字面量，进包含基本类型的元组，或者是 实现了  `Copy` trait 的类型，赋值的时候会直接复制的，因为他们的大小是确定的，
而且都比较简单，所以复制或处理他们的效率也是非常高的，当编译器遇到这些类型的时候，会默认选择拷贝值而不是借值

函数也跟变量是一样的：

```rust
fn main() {
    let s1 = String::from("ttt");
    borrow_value(s1);
    // println!("{}", s1);  报错，因为 s1 把值借给 函数 borrow_value 了
}

fn borrow_value(value: String) {
    println!("{}", value);
}
```

### 引用

引用的好处是，当使用复杂对象传递给函数时，借出去的值往往需要通过元组全部返还回来，不然借出去的变量之后就无法访问了。<br>
为了避免这种情况，就使用 & 引用来解决这个问题：

```rust
fn main() {
    let mut s = String::from("hello"); // s 可变
    change(&s); // 引用 reference 传递
    println!("{}", s); // s 可打印
}

fn change(some_string: &String) {
    // some_string 不可变，尽管 s 是可变的，因为 some_string 是引用
    some_string.push_str(", world"); // 报错！！！
}
```

默认引用是不可修改的，如果需要修改，可以写成 &mut xxx:

```rust
fn main() {
    let mut s = String::from("hello"); // s 可变
    change(&mut s); // 引用 reference 传递
    println!("{}", s); // s 可打印
}

fn change(some_string: &mut String) {
    some_string.push_str(", world"); // 这时候就可以修改了
}
```

注意，引用传递在一个范围内只能传递一次，例如：

```rust
let mut s = String::from("hello"); // s 可变
let mut s1 = &mut s;
let mut s2 = &mut s;
println!("{}", s1); // 报错，因为 s 又借给了s2, 所以 s1 没有值
println!("{}", s2); // 正确，最后一个引用可以访问值
```


报错如下：

```
    |
102 |     let mut s1 = &mut s;
    |                  ------ first mutable borrow occurs here
103 |     let mut s2 = &mut s;
    |                  ^^^^^^ second mutable borrow occurs here
104 |     println!("{}", s1); // 报错，因为 s 又借给了s2, 所以 s1 没有值
    |                    -- first borrow later used here
```


同时，rust 禁止一个变量在同一个范围，或同一个时间内，有可变的和不可变的两种引用，例如：

```rust
let mut s = String::from("hello"); // s 可变
let mut s1 = &s; // 不可变引用 &s
let mut s2 = &s; // 不可变引用 &s
let mut s3 = &mut s; // 可变引用 &mut s
println!("{} {} {}", s1, s2, s3);
```


#### 悬停指针 Dangling References

引用不能超过它自己的生命周期，例如：

```rust
fn dangle() -> &String { // 返回时报错，提示：Missing lifetime specifier [E0106]
    let s = String::from("1234");
    &s
}

//解析：
fn dangle() -> &String { // dangle returns a reference to a String

    let s = String::from("hello"); // s is a new String

    &s // we return a reference to the String, s
} // Here, s goes out of scope, and is dropped. Its memory goes away.
// Danger!

fn dangle(t: &String) -> &String {
    let s = String::from("1234");
    &s // 加上参数编译时报错：^^ returns a reference to data owned by the current function
}
```

&s 超出了自己的生命周期，导致无法编译通过

```rust
fn dangle(t: &String) -> &String {
    let s = String::from("1234");
    &t // 这是可以的，返回的 &t 引用是外部的，没有超出自己的生命周期
}

fn dangle() -> String { // 直接返回变量本身即可
    let s = String::from("1234");
    s
}
```


## 切片 slices
slice 是 reference 的一部门，字面量 &str 就是切片，考虑下面的代码：

```rust
fn first_word(s: &String) -> usize {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s); // word will get the value 5

    s.clear(); // this empties the String, making it equal to ""
    
    println!("{}", word);
    // word still has the value 5 here, but there's no more string that
    // we could meaningfully use the value 5 with. word is now totally invalid!
}
```

上面的例子，如果 s 被修改了，但是 word 仍然是指向 5，这个时候已经不对了，所以我们需要用切片，引用它的一段，如果那一段变化了，那它也
会跟着变化，例如：

```rust
let mut s = String::from("hello world");

let word = first_word(&s); // word will get the value 5
let hello = &s[0..5];
let world = &s[6..11];
println!("{} {} {}", word, hello, world);

s.clear(); // error, 因为 s 已经借了，所以无法执行 clear 操作
println!("{} {} {}",word, hello, world);
```
